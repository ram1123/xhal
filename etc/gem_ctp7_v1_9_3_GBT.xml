<?xml version="1.0" encoding="ISO-8859-1"?>
<!--  The tags attribute is a free test attribute which meaning is defined by the uHAL user -->
<node id="top">
  <node id="GEM_AMC">

    <!--TTC module -->
    <node id="TTC"  address="0x00300000"
          description="TTC control and monitoring. It takes care of locking to the TTC clock coming from the
                       backplane as well as decoding TTC commands and forwarding that to all other modules in
                       the design. It also provides several control and monitoring registers (resets, command
                       decoding configuration, clock and data status, bc0 status, command counters and a small spy buffer)"
          fw_is_module="true"
          fw_module_file="../common/hdl/ttc/ttc.vhd"
          fw_user_clock_signal="ttc_clks_i.clk_40"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="5"
          fw_reg_addr_lsb="0">
      <node id="CTRL" address="0x0"
            description="TTC control">
        <node id="MODULE_RESET" address="0x0" permission="w"
              description="TTC module reset"
              fw_write_pulse_signal="ttc_ctrl.reset_local"/>
        <node id="MMCM_RESET" address="0x1" permission="w"
              description="TTC MMCM reset"
              fw_write_pulse_signal="ttc_ctrl.mmcm_reset"/>
        <node id="CNT_RESET" address="0x2" permission="w"
              description="TTC counter reset"
              fw_write_pulse_signal="ttc_ctrl.cnt_reset"
              sw_ctrl_configure_set="0x1" sw_ctrl_start_set="0x1"/>
        <node id="MMCM_PHASE_SHIFT" address="0x3" permission="w"
              description="TTC MMCM phase shift trigger"
              fw_write_pulse_signal="ttc_ctrl.mmcm_phase_shift"/>
        <node id="L1A_ENABLE" address="0x4" mask="0x00000001" permission="rw"
              description="Enable L1As (L1As are blocked if this is 0)"
              fw_signal="ttc_ctrl.l1a_enable" fw_default="0b1"
              sw_ctrl_configure_set="0x0" sw_ctrl_start_set="0x1" sw_ctrl_stop_set="0x0"/>
      </node>
      <node id="CONFIG" address="0x5"
            description="TTC configuration -- used for setup TTC command decoding">
        <node id="CMD_BC0" address="0x0" mask="0x000000ff" permission="rw"
              description="BC0 command code"
              fw_signal="ttc_conf.cmd_bc0" fw_default="0x01"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_EC0" address="0x0" mask="0x0000ff00" permission="rw"
              description="EC0 command code"
              fw_signal="ttc_conf.cmd_ec0" fw_default="0x02"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_RESYNC" address="0x0" mask="0x00ff0000" permission="rw"
              description="Resync command code"
              fw_signal="ttc_conf.cmd_resync" fw_default="0x04"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_OC0" address="0x0" mask="0xff000000" permission="rw"
              description="OC0 command code"
              fw_signal="ttc_conf.cmd_oc0" fw_default="0x08"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_HARD_RESET" address="0x1" mask="0x000000ff" permission="rw"
              description="Hard-reset command code"
              fw_signal="ttc_conf.cmd_hard_reset" fw_default="0x10"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_CALPULSE" address="0x1" mask="0x0000ff00" permission="rw"
              description="Calibration pulse command code"
              fw_signal="ttc_conf.cmd_calpulse" fw_default="0x14"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_START" address="0x1" mask="0x00ff0000" permission="rw"
              description="START command code"
              fw_signal="ttc_conf.cmd_start" fw_default="0x18"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_STOP" address="0x1" mask="0xff000000" permission="rw"
              description="STOP command code"
              fw_signal="ttc_conf.cmd_stop" fw_default="0x1c"
              sw_ctrl_configure_confdb_check_set="true"/>
        <node id="CMD_TEST_SYNC" address="0x2" mask="0x000000ff" permission="rw"
              description="Test-sync command code"
              fw_signal="ttc_conf.cmd_test_sync" fw_default="0x20"
              sw_ctrl_configure_confdb_check_set="true"/>
      </node>
      <node id="STATUS" address="0x8"
            description="TTC status">
        <node id="MMCM_LOCKED" address="0x0" mask="0x00000001" permission="r"
              description="MMCM locked flag"
              fw_signal="ttc_status.mmcm_locked"
              sw_monitor_error_value="0"/>
        <node id="MMCM_UNLOCK_CNT" address="0x0" mask="0xffff0000" permission="r" description="MMCM unlock counter"
              fw_signal="mmcm_unlock_cnt"
              sw_monitor_warn_min_threshold="1"/>
        <node id="TTC_SINGLE_ERROR_CNT" address="0x1" mask="0x0000ffff" permission="r"
              description="TTC stream single bit error count"
              fw_signal="ttc_status.single_err"
              sw_monitor_warn_min_threshold="1"/>
        <node id="TTC_DOUBLE_ERROR_CNT" address="0x1" mask="0xffff0000" permission="r"
              description="TTC stream double bit error count"
              fw_signal="ttc_status.double_err"
              sw_monitor_error_min_threshold="1"/>
        <node id="BC0" address="0x2"
              description="TTC status">
          <node id="LOCKED" address="0x0" mask="0x00000001" permission="r"
                description="BC0 locked flag"
                fw_signal="ttc_status.bc0_status.locked"
                sw_monitor_error_value="0"/>
          <node id="UNLOCK_CNT" address="0x1" mask="0x0000ffff" permission="r"
                description="BC0 unlock count"
                fw_signal="ttc_status.bc0_status.unlocked_cnt"
                sw_monitor_error_min_threshold="1"/>
          <node id="OVERFLOW_CNT" address="0x2" mask="0x0000ffff" permission="r"
                description="BX counter overflow count (late or no BC0 received)"
                fw_signal="ttc_status.bc0_status.ovf_cnt"
                sw_monitor_error_min_threshold="1"/>
          <node id="UNDERFLOW_CNT" address="0x2" mask="0xffff0000" permission="r"
                description="BX counter underflow count (early BC0 received, one is normal after the
                             TTC module reset, but this should be reset by control software before each run)"
                fw_signal="ttc_status.bc0_status.udf_cnt"
                sw_monitor_error_min_threshold="1"/>
        </node>
      </node>

      <node id="CMD_COUNTERS" address="0xd"
            description="TTC command counters">
        <node id="L1A" address="0x0" permission="r"
              description="L1A count"
              fw_signal="ttc_cmds_cnt_arr(0)"/>
        <node id="BC0" address="0x1" permission="r"
              description="BC0 count"
              fw_signal="ttc_cmds_cnt_arr(1)"/>
        <node id="EC0" address="0x2" permission="r"
              description="EC0 count"
              fw_signal="ttc_cmds_cnt_arr(2)"/>
        <node id="RESYNC" address="0x3" permission="r"
              description="Resync count"
              fw_signal="ttc_cmds_cnt_arr(3)"/>
        <node id="OC0" address="0x4" permission="r"
              description="OC0 count"
              fw_signal="ttc_cmds_cnt_arr(4)"/>
        <node id="HARD_RESET" address="0x5" permission="r"
              description="Hard-reset count"
              fw_signal="ttc_cmds_cnt_arr(5)"/>
        <node id="CALPULSE" address="0x6" permission="r"
              description="Calibration pulse count"
              fw_signal="ttc_cmds_cnt_arr(6)"/>
        <node id="START" address="0x7" permission="r"
              description="START count"
              fw_signal="ttc_cmds_cnt_arr(7)"/>
        <node id="STOP" address="0x8" permission="r"
              description="STOP count"
              fw_signal="ttc_cmds_cnt_arr(8)"/>
        <node id="TEST_SYNC" address="0x9" permission="r"
              description="Test-sync count"
              fw_signal="ttc_cmds_cnt_arr(9)"/>
      </node>

      <node id="L1A_ID" address="0x17" mask="0x00ffffff" permission="r"
            description="L1A ID (increments with every L1A and resets with EC0), used by DAQ to tag event numbers"
            fw_signal="l1id_cnt"/>

      <node id="L1A_RATE" address="0x18" permission="r"
            description="L1A rate in Hz"
            fw_signal="l1a_rate"/>

      <node id="TTC_SPY_BUFFER" address="0x19" permission="r"
            description="TTC Spy buffer -- this is filled with TTC commands (from LSB to MSB)
                         and freezes until the user reads it out, once read out it resets and
                         fills up again with new TTC commands received from that point on"
            fw_signal="ttc_spy_buffer" fw_read_pulse_signal="ttc_spy_reset"/>
    </node>
    <!--end TTC module -->

    <!--Trigger module -->
    <node id="TRIGGER"  address="0x00800000"
          description="Trigger module handles everything related to sbit cluster data
                       (link synchronization, monitoring, local triggering, matching to L1A and reporting data to DAQ)"
          fw_is_module="true"
          fw_module_file="../common/hdl/trigger/trigger.vhd"
          fw_user_clock_signal="ttc_clk_i.clk_40"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="12"
          fw_reg_addr_lsb="0">

      <node id="CTRL" address="0x0"
            description="Trigger control">
        <node id="MODULE_RESET" address="0x0" permission="w"
              description="Trigger module reset"
              fw_write_pulse_signal="reset_local"/>
        <node id="CNT_RESET" address="0x1" permission="w"
              description="Trigger counter reset"
              fw_write_pulse_signal="reset_cnt"
              sw_ctrl_configure_set="0x1" sw_ctrl_start_set="0x1"/>
        <node id="OH_KILL_MASK" address="0x2" mask="0x00ffffff" permission="rw"
              description="OH trigger kill mask (kills all sbits from the corresponding OHs)"
              fw_signal="oh_mask"
              fw_default="0x000000"/>
      </node>

      <node id="STATUS" address="0x10"
            description="Trigger status">
        <node id="OR_TRIGGER_RATE" address="0x0" permission="r"
              description="OR-Trigger rate (Hz) -- this trigger fires whenever there's at least one valid sbit cluster on any link"
              fw_signal="or_trigger_rate"
              sw_monitor_warn_min_threshold="1000000"/>
        <node id="OR_TRIGGER_CNT" address="0x1" permission="r"
              description="OR-Trigger count -- this trigger fires whenever there's at least one valid sbit cluster on any link"
              fw_signal="or_trigger_cnt"/>
      </node>

      <node id="OH${OH_IDX}" address="0x100"
            description="Trigger link for OH ${OH_IDX}"
            generate="true" generate_size="12" generate_address_step="0x100" generate_idx_var="OH_IDX">
        <node id="TRIGGER_RATE" address="0x0" permission="r"
              description="Trigger rate (Hz) -- this trigger fires whenever there's at least one valid sbit cluster"
              fw_signal="trigger_rate(${OH_IDX})"
              sw_monitor_warn_min_threshold="1000000"/>
        <node id="TRIGGER_CNT" address="0x1" permission="r"
              description="Trigger count -- this trigger fires whenever there's at least one valid sbit cluster"
              fw_signal="trigger_cnt(${OH_IDX})"
              sw_monitor_warn_min_threshold="1000000"/>
        <node id="CLUSTER_SIZE_${CS_IDX}_RATE" address="0x10" permission="r"
              description="Rate of cluster size ${CS_IDX} (size 0 means no sbit clusters)"
              fw_signal="cluster_cnt_rate(${OH_IDX} * 9 + ${CS_IDX})"
              generate="true" generate_size="9" generate_address_step="0x1" generate_idx_var="CS_IDX"/>
        <node id="CLUSTER_SIZE_${CS_IDX}_CNT" address="0x20" permission="r"
              description="Count of cluster size ${CS_IDX} (size 0 means no sbit clusters)"
              fw_signal="cluster_cnt(${OH_IDX} * 9 + ${CS_IDX})"
              generate="true" generate_size="9" generate_address_step="0x1" generate_idx_var="CS_IDX"/>
        <node id="LINK0_NOT_VALID_CNT" address="0xa0" mask="0x0000ffff" permission="r"
              description="Count of valid flag being 0 in the sync FIFO for link 0"
              fw_signal="not_valid_cnt(${OH_IDX})(15 downto 0)"
              sw_monitor_error_min_threshold="100"/>
        <node id="LINK1_NOT_VALID_CNT" address="0xa0" mask="0xffff0000" permission="r"
              description="Count of valid flag being 0 in the sync FIFO for link 1"
              fw_signal="not_valid_cnt(${OH_IDX})(31 downto 16)"
              sw_monitor_error_min_threshold="100"/>
        <node id="LINK0_MISSED_COMMA_CNT" address="0xa1" mask="0x0000ffff" permission="r"
              description="Count of missed comma character at the expected time for link 0 (this indicates an out-of-sync condition)"
              fw_signal="missed_comma_cnt(${OH_IDX})(15 downto 0)"
              sw_monitor_error_min_threshold="1"/>
        <node id="LINK1_MISSED_COMMA_CNT" address="0xa1" mask="0xffff0000" permission="r"
              description="Count of missed comma character at the expected time for link 1 (this indicates an out-of-sync condition)"
              fw_signal="missed_comma_cnt(${OH_IDX})(31 downto 16)"
              sw_monitor_error_min_threshold="1"/>
        <node id="LINK0_INVALID_SIZE_CNT" address="0xa2" mask="0x0000ffff" permission="r"
              description="Count of invalid cluster size on link 0 (for VFAT2 case the cluster size must always be equal to 7)"
              fw_signal="invalid_size_cnt(${OH_IDX})(15 downto 0)"
              sw_monitor_error_min_threshold="1"/>
        <node id="LINK1_INVALID_SIZE_CNT" address="0xa2" mask="0xffff0000" permission="r"
              description="Count of invalid cluster size on link 1 (for VFAT2 case the cluster size must always be equal to 7)"
              fw_signal="invalid_size_cnt(${OH_IDX})(31 downto 16)"
              sw_monitor_error_min_threshold="1"/>
        <node id="LINK0_OVERFLOW_CNT" address="0xa3" mask="0x0000ffff" permission="r"
              description="Count of overflow occurances in the sync FIFO for link 0"
              fw_signal="link_overflow_cnt(${OH_IDX})(15 downto 0)"
              sw_monitor_error_min_threshold="1"/>
        <node id="LINK1_OVERFLOW_CNT" address="0xa3" mask="0xffff0000" permission="r"
              description="Count of overflow occurances in the sync FIFO for link 1"
              fw_signal="link_overflow_cnt(${OH_IDX})(31 downto 16)"
              sw_monitor_error_min_threshold="1"/>
        <node id="LINK0_UNDERFLOW_CNT" address="0xa4" mask="0x0000ffff" permission="r"
              description="Count of underflow occurances in the sync FIFO for link 0"
              fw_signal="link_underflow_cnt(${OH_IDX})(15 downto 0)"
              sw_monitor_error_min_threshold="1"/>
        <node id="LINK1_UNDERFLOW_CNT" address="0xa4" mask="0xffff0000" permission="r"
              description="Count of underflow occurances in the sync FIFO for link 1"
              fw_signal="link_underflow_cnt(${OH_IDX})(31 downto 16)"
              sw_monitor_error_min_threshold="1"/>
        <node id="LINK0_SYNC_WORD_CNT" address="0xa5" mask="0x0000ffff" permission="r"
              description="Count of sync words seen on link 0"
              fw_signal="sync_word_cnt(${OH_IDX})(15 downto 0)"/>
        <node id="LINK1_SYNC_WORD_CNT" address="0xa5" mask="0xffff0000" permission="r"
              description="Count of sync words seen on link 1"
              fw_signal="sync_word_cnt(${OH_IDX})(31 downto 16)"/>
        <node id="DEBUG_LAST_CLUSTER_${CLUSTER_IDX}" address="0xf0" mask="0x0000ffff" permission="r"
              description="Last cluster ${CLUSTER_IDX}"
              fw_signal="'0' &amp; sbit_clusters_i(${OH_IDX})(${CLUSTER_IDX}).size &amp; '0' &amp; sbit_clusters_i(${OH_IDX})(${CLUSTER_IDX}).address"
              generate="true" generate_size="8" generate_address_step="0x1" generate_idx_var="CLUSTER_IDX"/>
      </node>

    </node>
    <!--end trigger module -->

    <!--GEM System module -->
    <node id="GEM_SYSTEM"  address="0x00900000"
          description="This module is controlling GEM AMC System wide settings"
          fw_is_module="true"
          fw_module_file="../common/hdl/misc/gem_system_regs.vhd"
          fw_user_clock_signal="ipb_clk_i"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="16"
          fw_reg_addr_lsb="0">

      <node id="CTRL" address="0x100">
        <node id="CNT_RESET" address="0x0" permission="w"
              description="GEM system counters reset"
              fw_write_pulse_signal="reset_cnt"
              sw_ctrl_configure_set="0x1" sw_ctrl_start_set="0x1"/>
      </node>

      <node id="TK_LINK_RX_POLARITY" address="0x0" mask="0x00ffffff" permission="rw"
            description="RX polarity of the track/control links (bit 0 corresponds to link 0)"
            fw_signal="tk_rx_polarity" fw_default="0x000000"/>
      <node id="TK_LINK_TX_POLARITY" address="0x1" mask="0x00ffffff" permission="rw"
            description="TX polarity of the track/control links (bit 0 corresponds to link 0)"
            fw_signal="tk_tx_polarity" fw_default="0x000000"/>
      <node id="BOARD_ID" address="0x2" mask="0x0000ffff" permission="rw"
            description="Board ID that gets embedded in the AMC13 header"
            fw_signal="board_id" fw_default="0xbeef"/>
      <node id="BOARD_TYPE" address="0x2" mask="0x000f0000" permission="r"
            description="Board type: 0 means GLIB, 1 means CTP7"
            fw_signal="board_type"/>

      <node id="RELEASE" address="0x3">
        <node id="MAJOR" address="0x0" mask="0x00ff0000" permission="r"
              description="Firmware release major version"
              fw_signal="std_logic_vector(to_unsigned(version_major, 8))"/>
        <node id="MINOR" address="0x0" mask="0x0000ff00" permission="r"
              description="Firmware release minor version"
              fw_signal="std_logic_vector(to_unsigned(version_minor, 8))"/>
        <node id="BUILD" address="0x0" mask="0x000000ff" permission="r"
              description="Firmware release build version"
              fw_signal="std_logic_vector(to_unsigned(version_build, 8))"/>
        <node id="DATE" address="0x1" permission="r"
              description="Firmware release date (read as hex)"
              fw_signal="firmware_date"/>
      </node>

      <node id="CONFIG" address="0x5">
        <node id="NUM_OF_OH" address="0x0" mask="0x0000001f" permission="r"
              description="Number of supported optohybrids"
              fw_signal="num_of_oh"/>
        <node id="USE_GBT" address="0x0" mask="0x00000100" permission="r"
              description="If 1 then this firmware is using GBT links to communicate with optohybrids,
                           if 0 then 8b10b links are used"
              fw_signal="use_gbt"/>
        <node id="USE_TRIG_LINKS" address="0x0" mask="0x00000200" permission="r"
              description="If 1 then this firmware supports trigger links, if 0 then trigger links are disabled"
              fw_signal="use_trig_links"/>
      </node>

      <node id="TESTS" address="0x200">
        <node id="GBT_LOOPBACK_EN" address="0x0" mask="0x00000001" permission="rw"
              description="GBT Loopback test enable -- if this is true then all GBT links are redirected to the loopback test
                           module and the test module is enabled (communication with optohybrid is not possible during the test)"
              fw_signal="loopback_gbt_test_en" fw_default="0b0"
              sw_ctrl_configure_set="0x0" sw_ctrl_start_set="0x0"/>
        <node id="8B10B_LOOPBACK_EN" address="0x0" mask="0x00000002" permission="rw"
              description="8b10b loopback test enable -- if this is true then all 8b10b DAQ/control links are redirected to the
                           loopback test module and the test module is enabled (communication with optohybrid is not possible
                           during the test)"
              fw_signal="loopback_8b10b_test_en" fw_default="0b0"
              sw_ctrl_configure_set="0x0" sw_ctrl_start_set="0x0"/>
        <node id="8B10B_LOOPBACK_USE_TRIG_LINKS" address="0x0" mask="0x00000004" permission="rw"
              description="If this bit is set then the 8b10b loopback test will also expect the DAQ TX data to be looped back
                           to the trigger links and do the sync and count the errors on these links"
              fw_signal="loopback_8b10b_use_trig" fw_default="0b0"
              sw_ctrl_configure_set="0x0" sw_ctrl_start_set="0x0"/>
      </node>

      <node id="LEGACY_SYSTEM" address="0x10000"
            description="Legacy system registers (taken from GLIB system core). These should be removed once the software is
                         made compatible with the new system registers.">

        <node id="BOARD_ID" address="0x0" permission="r"
              description="GLIB Board ID code"
              fw_signal="legacy_board_id"/>
        <node id="SYSTEM_ID" address="0x1" permission="r"
              description="GLIB System ID code"
              fw_signal="legacy_sys_id"/>
        <node id="FIRMWARE_VERSION" address="0x2" permission="r"
              description="GLIB firmware version + firmware date"
              fw_signal="legacy_fw_version"/>

        <!--node id="IPBus"   address="0x10"
                 description="counters for IPBus transactions">
        <node id="Strobe"   address="0x0"
              description="Counters for the IPBus strobe requests">
          <node id="OptoHybrid_0"  address="0x0"  permission="r"
                description="">
            <node id="Reset"       address="0x0"  permission="w"
                  description=""/>
          </node>
          <node id="OptoHybrid_1"  address="0x1"  permission="r"
                description="">
            <node id="Reset"       address="0x0"  permission="w"
                  description=""/>
          </node>
          <node id="TRK_0"         address="0x2"  permission="r"
                description="">
            <node id="Reset"       address="0x0"  permission="w"
                  description=""/>
          </node>
          <node id="TRK_1"         address="0x3"  permission="r"
                description="">
            <node id="Reset"       address="0x0"  permission="w"
                  description=""/>
          </node>
          <node id="Counters"      address="0x4"  permission="r"
                description="">
            <node id="Reset"       address="0x0"  permission="w"
                  description=""/>
          </node>
        </node>
        <node id="Ack"      address="0x5"
              description="Counters for the IPBus acknowledgements">
          <node id="OptoHybrid_0"  address="0x0"  permission="r"
                description="">
            <node id="Reset"       address="0x0"  permission="w"
                  description=""/>
          </node>
          <node id="OptoHybrid_1"  address="0x1"  permission="r"
                description="">
            <node id="Reset"       address="0x0"  permission="w"
                  description=""/>
          </node>
          <node id="TRK_0"         address="0x2"  permission="r"
                description="">
            <node id="Reset"       address="0x0"  permission="w"
                  description=""/>
          </node>
          <node id="TRK_1"         address="0x3"  permission="r"
                description="">
            <node id="Reset"       address="0x0"  permission="w"
                  description=""/>
          </node>
          <node id="Counters"      address="0x4"  permission="r"
                description="">
            <node id="Reset"       address="0x0"  permission="w"
                  description=""/>
          </node>
        </node>
        </node-->
      </node>
    </node>

    <!--GEM Tests module -->
    <node id="GEM_TESTS"  address="0x00A00000"
          description="This module is controlling various hardware tests e.g. fiber loopback"
          fw_is_module="true"
          fw_module_file="../common/hdl/tests/gem_tests.vhd"
          fw_user_clock_signal="ttc_clk_i.clk_40"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="16"
          fw_reg_addr_lsb="0">

      <node id="CTRL" address="0x0">
        <node id="RESET" address="0x0" permission="w"
              description="GEM system counters reset"
              fw_write_pulse_signal="reset_local"/>
      </node>

      <node id="GBT_LOOPBACK" address="0x1000"
              description="GBT loopback test submodule">
        <node id="CTRL" address="0x0">
	  <node id="LOOP_THROUGH_OH" address="0x0" mask="0x00000001" permission="rw"
		description="This flag is used to indicate if the loopback test goes through OH or not.
                             If it's set to 1 then only elinks that go to OH FPGA are checked."
		fw_signal="gbt_loop_through_oh" fw_default="0b0"/>
        </node>
        <node id="LINK_${GBT_IDX}"  address="0x10"
              description="Link specific registers for GBT ${GBT_IDX}"
              generate="true" generate_size="36" generate_address_step="0x10" generate_idx_var="GBT_IDX">

          <node id="SYNC_DONE" mask="0x00000001" permission="r" address="0x0"
                description="Indicates whether or not the sync has been acquired between TX and RX"
                fw_signal="gbt_loop_sync_done_arr(${GBT_IDX})"/>
          <node id="MEGA_WORD_CNT" permission="r" address="0x1"
                description="Number of generated data words received by the loopback RX"
                fw_signal="gbt_loop_mega_word_cnt_arr(${GBT_IDX})"/>
          <node id="ERROR_CNT" permission="r" address="0x2"
                description="Number of errors found in the received loopback data"
                fw_signal="gbt_loop_error_cnt_arr(${GBT_IDX})"/>
        </node>
      </node>

      <node id="8b10b_LOOPBACK" address="0x2000"
            description="8b10b loopback test submodule">
        <node id="LINK_${OH_IDX}"  address="0x10"
              description="Link specific registers for 8b10b link ${OH_IDX}"
              generate="true" generate_size="12" generate_address_step="0x10" generate_idx_var="OH_IDX">

          <node id="DAQ_SYNC_DONE" mask="0x00000001" permission="r" address="0x0"
                description="Indicates whether or not the sync has been acquired between the DAQ TX and DAQ RX"
                fw_signal="daq_8b10b_loop_sync_done_arr(${OH_IDX})"/>
          <node id="TRIG0_SYNC_DONE" mask="0x00000002" permission="r" address="0x0"
                description="Indicates whether or not the sync has been acquired between the DAQ TX and TRIG0 RX"
                fw_signal="trig0_8b10b_loop_sync_done_arr(${OH_IDX})"/>
          <node id="TRIG1_SYNC_DONE" mask="0x00000004" permission="r" address="0x0"
                description="Indicates whether or not the sync has been acquired between the DAQ TX and TRIG1 RX"
                fw_signal="trig1_8b10b_loop_sync_done_arr(${OH_IDX})"/>
          <node id="MEGA_WORD_CNT" permission="r" address="0x1"
                description="Number of generated data words received by the loopback RX"
                fw_signal="all_8b10b_loop_mega_word_cnt_arr(${OH_IDX})"/>
          <node id="DAQ_ERROR_CNT" permission="r" address="0x2"
                description="Number of errors found in the received loopback data on the DAQ RX link"
                fw_signal="daq_8b10b_loop_error_cnt_arr(${OH_IDX})"/>
          <node id="TRIG0_ERROR_CNT" permission="r" address="0x3"
                description="Number of errors found in the received loopback data on the TRIG0 RX link"
                fw_signal="trig0_8b10b_loop_error_cnt_arr(${OH_IDX})"/>
          <node id="TRIG1_ERROR_CNT" permission="r" address="0x4"
                description="Number of errors found in the received loopback data on the TRIG1 RX link"
                fw_signal="trig1_8b10b_loop_error_cnt_arr(${OH_IDX})"/>
        </node>
      </node>

    </node>

    <!--DAQ module -->
    <node id="DAQ"  address="0x00700000"
          description="DAQ module buffers track data, builds events, analyses the data for consistency
                       and ships off the events with all the needed headers and trailers to AMC13 over DAQLink"
          fw_is_module="true"
          fw_module_file="../common/hdl/daq/daq.vhd"
          fw_user_clock_signal="ipb_clk_i"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="8"
          fw_reg_addr_lsb="0">

      <node id="CONTROL"  address="0x0"
            description="DAQ Control">
        <node id="DAQ_ENABLE"         address="0x0" mask="0x00000001" permission="rw"
              description="If this is set to 0, there will be no data sent to AMC13 and TTS state will always be READY (0x8)"
              fw_signal="daq_enable" fw_default="0b0"/>
        <node id="DAQ_LINK_RESET"     address="0x0" mask="0x00000004" permission="rw"
              description="Directly connected to DAQLink module reset port. BU is
                           advising against ever using it except for powerup, but it
                           may clear some error conditions (like daqlink_almost_ful
                           stuck at 1). AMC13 reset is probably required after this."
              fw_signal="reset_daqlink_ipb" fw_default="0b0"/>
        <node id="RESET"              address="0x0" mask="0x00000008" permission="rw"
              description="Clears all FIFOs, state flags and counters. It also stops and
                           resets all state machines (no events will be built, recorded
                           or sent during reset)
                           When set to 1, it will be held in reset state until 0 is
                           explicitly written (this can be changed in the future if
                           necessary)"
              fw_signal="reset_local" fw_default="0b0"/>
        <node id="TTS_OVERRIDE"       address="0x0" mask="0x000000f0" permission="rw"
              description="When not 0, it will override the AMC TTS state with the
                           provided value (e.g. writing 0x8 will force AMC to always be
                           in TTS READY state)"
              fw_signal="tts_override" fw_default="0x0"/>
        <node id="INPUT_ENABLE_MASK"  address="0x0" mask="0xffffff00" permission="rw"
              description="This is a bitmask telling AMC to enable certain inputs (least
                           significant bit is input 0). Only first is enabled by default"
              fw_signal="input_mask" fw_default="0x1"/>
        <node id="DAV_TIMEOUT"        address="0x6"  mask="0x00ffffff" permission="rw"
              description="This setting controls how long DAQ will wait for individual
                           inputs to report data before calling it timed-out  (if timeout
                           occurs a header and trailer for that chamber will still be
                           inserted and timeout flag will be set there, though no VFAT
                           payload will be present). Units = clock cycles @ 25MHz
                           (current DAQLink clk frequency)"
              fw_signal="dav_timeout" fw_default="0x3d090"/>
      </node>

      <node id="STATUS"  address="0x1"
            description="DAQ global status registers">
        <node id="DAQ_LINK_RDY"    address="0x0"  mask="0x00000001" permission="r"
              description="When this is 1, it means that AMC is in good communication
                           with AMC13. It must be 1 for AMC to be able to send data."
              fw_signal="daq_ready"/>
        <node id="DAQ_CLK_LOCKED"  address="0x0"  mask="0x00000002" permission="r"
              description="This flag is 1 if DAQ clock is locked at this moment"
              fw_signal="daq_clk_locked_i"/>
        <node id="TTC_RDY"         address="0x0"  mask="0x00000004" permission="r"
              description="This flag is 1 if TTC clock MMCM is locked"
              fw_signal="ttc_status_i.mmcm_locked"/>
        <node id="DAQ_LINK_AFULL"       address="0x0"  mask="0x00000008" permission="r"
              description="This bit comes directly from DAQLink module, indicating
                           that its internal buffers are almost full. No events will be sent
                           when this bit is 1 (though events can still be built and
                           stored in the Input and Event FIFOs)"
              fw_signal="daq_almost_full"
              sw_monitor_error_min_threshold="1"/>
        <node id="DAQ_OUTPUT_FIFO_HAD_OVERFLOW"       address="0x0"  mask="0x00000010" permission="r"
              description="This bit is set if DAQ output FIFO has ever been full (critical -- data loss)"
              fw_signal="err_daqfifo_full"
              sw_monitor_error_min_threshold="1"/>
        <node id="TTC_BC0_LOCKED"       address="0x0"  mask="0x00000020" permission="r"
              description="This bit is set if BC0 is currently locked (last BC0 arrived at the expected time)"
              fw_signal="ttc_status_i.bc0_status.locked"/>
        <node id="L1A_FIFO_HAD_OVERFLOW"       address="0x0"  mask="0x00800000" permission="r"
              description="This bit is latched whenever L1A FIFO overflow is asserted.
                           This means that one or more L1As were lost, so we are
                           out-of-sync: resync or reset is needed"
              fw_signal="err_l1afifo_full"
              sw_monitor_error_min_threshold="1"/>
        <node id="L1A_FIFO_IS_UNDERFLOW"       address="0x0"  mask="0x01000000" permission="r"
              description="L1A FIFO is in underflow at this moment (this bit is not latched)"
              fw_signal="l1afifo_underflow"
              sw_monitor_error_min_threshold="1"/>
        <node id="L1A_FIFO_IS_FULL"       address="0x0"  mask="0x02000000" permission="r"
              description="L1A FIFO is full at this moment (this bit is not latched)"
              fw_signal="l1afifo_full"
              sw_monitor_error_min_threshold="1"/>
        <node id="L1A_FIFO_IS_NEAR_FULL"       address="0x0"  mask="0x04000000" permission="r"
              description="This bit gets asserted when L1A FIFO gets 75% full and deasserted when it gets down to 50%"
              fw_signal="l1afifo_near_full"/>
        <node id="L1A_FIFO_IS_EMPTY"       address="0x0"  mask="0x08000000" permission="r"
              description="L1A FIFO is empty at this moment (this bit is not latched)"
              fw_signal="l1afifo_empty"/>
        <node id="TTS_STATE"       address="0x0"  mask="0xf0000000" permission="r"
              description="Current TTS state (READY, BUSY, ERROR, WARN, OUT-OF-SYNC)"
              fw_signal="tts_state"/>
      </node>

      <node id="EXT_STATUS"  address="0x2"
            description="DAQ global extended status registers">
        <node id="NOTINTABLE_ERR"  address="0x0"  mask="0x0000ffff" permission="r"
              description="This counter is counting DAQLink GTX/GTH not-in-table errors"
              fw_signal="daq_notintable_err_cnt"/>
        <node id="DISPER_ERR"      address="0x1"  mask="0x0000ffff" permission="r"
              description="This counter is counting DAQLink GTX/GTH dispersion errors"
              fw_signal="daq_disper_err_cnt"/>
        <node id="L1AID"           address="0x2"  mask="0x00ffffff" permission="r"
              description="Current L1A ID (similar to event number, but this may be a bit ahead of
                           that if we're still waiting for data for unprocessed L1As)"
              fw_signal="ttc_daq_cntrs_i.l1id"/>
        <node id="EVT_SENT"        address="0x3"  permission="r"
              description="Number of events shipped out to DAQLink"
              fw_signal="std_logic_vector(cnt_sent_events)"/>
        <node id="MAX_DAV_TIMER"   address="0x5"  mask="0x00ffffff" permission="r"
              description="This indicates the maximum amount of time that DAQ had
                           to wait for all inputs to report data (can be used to optimize
                           DAV timeout setting). Units = clock cycles @ DAQ clock frequency (currently using 40.08MHz TTC clock)
                           (current DAQLink clk frequency)"
              fw_signal="std_logic_vector(max_dav_timer)"/>
        <node id="LAST_DAV_TIMER"  address="0x6"  mask="0x00ffffff" permission="r"
              description="This indicates how DAQ had to wait for all inputs to report
                           data for the last event (mostly for debugging). Units = clock
                           cycles @ DAQ clock frequency (currently using 40.08MHz TTC clock)"
              fw_signal="std_logic_vector(last_dav_timer)"/>
        <node id="L1A_FIFO_DATA_CNT"  address="0x7"  mask="0x00001fff" permission="r"
              description="Current number of words in the L1A FIFO (current depth is 8192)"
              fw_signal="l1afifo_data_cnt"/>
        <node id="DAQ_FIFO_DATA_CNT"  address="0x7"  mask="0x1fff0000" permission="r"
              description="Current number of words in the DAQ output FIFO (current depth is 8192)"
              fw_signal="daqfifo_data_cnt"/>
        <node id="L1A_FIFO_NEAR_FULL_CNT"  address="0x8"  mask="0x0000ffff" permission="r"
              description="Number of clocks L1A FIFO was near-full (asserted at 75%, deasserted at 50%)"
              fw_signal="l1afifo_near_full_cnt"
              sw_monitor_warn_min_threshold="100"/>
        <node id="DAQ_FIFO_NEAR_FULL_CNT"  address="0x8"  mask="0xffff0000" permission="r"
              description="Number of clocks DAQ output FIFO was near-full (asserted at 75%, deasserted at 50%)"
              fw_signal="daqfifo_near_full_cnt"
              sw_monitor_warn_min_threshold="100"/>
        <node id="DAQ_ALMOST_FULL_CNT"  address="0x9"  mask="0x0000ffff" permission="r"
              description="Number of clocks DAQLink has asserted almost-full flag"
              fw_signal="daqlink_afull_cnt"/>
        <node id="TTS_WARN_CNT"  address="0x9"  mask="0xffff0000" permission="r"
              description="Number of clocks we reported TTS WARNING state"
              fw_signal="tts_warning_cnt"
              sw_monitor_warn_min_threshold="100"/>
        <node id="DAQ_WORD_RATE"  address="0xa"  permission="r"
              description="Rate of 64bit words being sent out to the DAQLink in Hz (multiply by 64 to get bitrate)"
              fw_signal="daq_word_rate"
              sw_monitor_warn_min_threshold="40000"/> <!-- currently running DAQ at 50MHz, which is 3.2Gbs, so warning at 2.5Gbs (could increase to 80MHz to get 5Gbs) -->
      </node>

      <node id="EXT_CONTROL"  address="0xe"
            description="DAQ global extended configuration registers">
        <node id="RUN_TYPE"       address="0x1"  mask="0x0f000000" permission="rw"
              description="User settable run type that gets embedded into the AMC header"
              fw_signal="run_type" fw_default="0x0"/>
        <node id="RUN_PARAMS"     address="0x1"  mask="0x00ffffff" permission="rw"
              description="User settable run params that gets embedded into the AMC header"
              fw_signal="run_params" fw_default="0x000000"/>
      </node>

      <node id="OH${OH_IDX}"  address="0x10"
            description="Link specific registers for OH${OH_IDX}"
            generate="true" generate_size="12" generate_address_step="0x10" generate_idx_var="OH_IDX">

        <node id="CONTROL"  address="0x0">
          <node id="EOE_TIMEOUT" address="0x3"  mask="0x00ffffff" permission="rw"
                description="Units = clock cycles @ 160MHz.
                             If no new data was received in this amount of time, AMC
                             will close the current event and report it to DAQ. This is one
                             of the two ways to close an event, the other is to get new
                             data with different BX number"
                fw_signal="input_control_arr(${OH_IDX}).eb_timeout_delay" fw_default="0x0030d4"/>
        </node>

        <node id="STATUS"  address="0x0">
          <node id="VFAT_MIXED_EC"    mask="0x00000002" permission="r" address="0x0"
                description="There was at least one event with mixed VFAT Event IDs"
                fw_signal="input_status_arr(${OH_IDX}).err_mixed_vfat_ec"/>
          <node id="VFAT_MIXED_BC"  mask="0x00000004" permission="r" address="0x0"
                description="There was at least one event with mixed VFAT BX IDs"
                fw_signal="input_status_arr(${OH_IDX}).err_mixed_vfat_bc"/>
          <node id="OH_MIXED_BC"         mask="0x00000008" permission="r" address="0x0"
                description="There was at least one event with mixed OH BX IDs (OH BX
                             ID is reported for every VFAT block, but not sent to
                             AMC13)."
                fw_signal="input_status_arr(${OH_IDX}).err_mixed_oh_bc"/>

          <node id="VFAT_TOO_MANY"      mask="0x00000010" permission="r" address="0x0"
                description="Corruption: more than 24 VFATs in event"
                fw_signal="input_status_arr(${OH_IDX}).err_event_bigger_than_24"/>
          <node id="VFAT_SMALL_BLOCK"   mask="0x00000020" permission="r" address="0x0"
                description="Corruption: VFAT block smaller than 192bits"
                fw_signal="input_status_arr(${OH_IDX}).err_vfat_block_too_small"/>
          <node id="VFAT_LARGE_BLOCK"   mask="0x00000040" permission="r" address="0x0"
                description="Corruption: VFAT block bigger than 192bits"
                fw_signal="input_status_arr(${OH_IDX}).err_vfat_block_too_big"/>
          <node id="VFAT_NO_MARKER"     mask="0x00000080" permission="r" address="0x0"
                description="Corruption: VFAT marker not detected.
                             There was at least one VFAT block not conforming to the
                             pattern of Axxx Cxxx Exxx... (see VFAT data format)
                             Note that this data will still be included in the current event
                             and sent to AMC13, but it will not be considered in
                             end-of-event detection"
                fw_signal="input_status_arr(${OH_IDX}).err_corrupted_vfat_data"/>
          <node id="INPUT_FIFO_HAD_OFLOW"   mask="0x00000100" permission="r" address="0x0"
                description="Critical: Input FIFO overflow occurred.
                             This bit is latched if Input FIFO was ever full when receiving
                             new data - this means data was lost.
                             TTS ERROR is asserted when this bit is 1"
                fw_signal="input_status_arr(${OH_IDX}).err_infifo_full"/>
          <node id="INPUT_FIFO_HAD_UFLOW"   mask="0x00000200" permission="r" address="0x0"
                description="Critical: Input FIFO underflow occurred.
                             This bit is latched if Input FIFO underflow was ever
                             detected. This means that Event FIFO indicated that there
                             should be more data than was stored in Input FIFO. This
                             might happen due to overflow or some other malfunction.
                             TTS ERROR is asserted when this bit is 1"
                fw_signal="input_status_arr(${OH_IDX}).err_infifo_underflow"/>
          <node id="EVENT_FIFO_HAD_OFLOW"   mask="0x00000400" permission="r" address="0x0"
                description="Critical: Event FIFO overflow occurred.
                             This bit is latched if Event FIFO was ever full when trying to
                             build a new event. This means data was lost.
                             It's not likely that this will ever be asserted because Input
                             FIFO should overflow first.
                             TTS ERROR is asserted when this bit is 1"
                fw_signal="input_status_arr(${OH_IDX}).err_evtfifo_full"/>
          <node id="EVT_SIZE_ERR"           mask="0x00000800" permission="r" address="0x0"
                description="Critical: Event size overflow occurred.
                             This bit is latched if there was an event containing more
                             than 4096 VFAT blocks. Input FIFO and Event FIFO will be
                             out-of-sync. This might happen if end-of-event is not
                             detected properly or for whatever reason AMC is receiving
                             a stream of VFAT blocks indicating that they belong to the
                             same event (EC/BC is the same)
                             TTS ERROR is asserted when this bit is 1"
                fw_signal="input_status_arr(${OH_IDX}).err_event_too_big"/>
          <node id="TTS_STATE"           mask="0x0000f000" permission="r" address="0x0"
                description="Input TTS state (gets integrated into global TTS state later)"
                fw_signal="input_status_arr(${OH_IDX}).tts_state"/>
          <node id="INPUT_FIFO_IS_UFLOW"    mask="0x01000000" permission="r" address="0x0"
                description="Current status: Input FIFO is in underflow"
                fw_signal="input_status_arr(${OH_IDX}).infifo_underflow"/>
          <node id="INPUT_FIFO_IS_FULL"     mask="0x02000000" permission="r" address="0x0"
                description="Current status: Input FIFO is full"
                fw_signal="input_status_arr(${OH_IDX}).infifo_full"/>
          <node id="INPUT_FIFO_IS_AFULL"    mask="0x04000000" permission="r" address="0x0"
                description="Current status: Input FIFO is near-full (asserted at 75% and deasserted at 50%)"
                fw_signal="input_status_arr(${OH_IDX}).infifo_near_full"/>
          <node id="INPUT_FIFO_IS_EMPTY"    mask="0x08000000" permission="r" address="0x0"
                description="Current status: Input FIFO is empty"
                fw_signal="input_status_arr(${OH_IDX}).infifo_empty"/>
          <node id="EVENT_FIFO_IS_UFLOW"    mask="0x10000000" permission="r" address="0x0"
                description="Current status: Event FIFO is in underflow"
                fw_signal="input_status_arr(${OH_IDX}).evtfifo_underflow"/>
          <node id="EVENT_FIFO_IS_FULL"     mask="0x20000000" permission="r" address="0x0"
                description="Current status: Event FIFO is full"
                fw_signal="input_status_arr(${OH_IDX}).evtfifo_full"/>
          <node id="EVENT_FIFO_IS_AFULL"    mask="0x40000000" permission="r" address="0x0"
                description="Current status: Event FIFO is near-full (asserted at 75% and deasserted at 50%)"
                fw_signal="input_status_arr(${OH_IDX}).evtfifo_near_full"/>
          <node id="EVENT_FIFO_IS_EMPTY"    mask="0x80000000" permission="r" address="0x0"
                description="Current status: Event FIFO is empty"
                fw_signal="input_status_arr(${OH_IDX}).evtfifo_empty"/>
        </node>

        <node id="COUNTERS">
          <node id="CORRUPT_VFAT_BLK_CNT"  address="0x1" permission="r"
                description="This counter is incremented when a VFAT block does not
                             conform to the pattern of Axxx Cxxx Exxx... (see VFAT
                             data format)
                             Note that this data is still included in events and sent to
                             AMC13, but it does not participate in end-of-event
                             detection."
                fw_signal="input_status_arr(${OH_IDX}).cnt_corrupted_vfat"/>
          <node id="EVN"                   address="0x2" mask="0x00ffffff" permission="r"
                description="Current event number of the event builder.
                             This counter starts at 1 and increments with each
                             end-of-event detection. This number should be similar to
                             the number of events sent to AMC13 in normal operation,
                             but it might not always be exactly the same because there's
                             some latency between building an event and sending it. In
                             addition, event sending could stop due to DAQ FIFO being
                             almost full or DAQLink not being ready."
                fw_signal="input_status_arr(${OH_IDX}).eb_event_num"/>
          <node id="INPUT_FIFO_DATA_CNT"  address="0x4"  mask="0x00000fff" permission="r"
                description="Current number of words in the Input FIFO (current depth is 4096)"
                fw_signal="chamber_infifos(${OH_IDX}).data_cnt"/>
          <node id="EVT_FIFO_DATA_CNT"  address="0x4"  mask="0x0fff0000" permission="r"
                description="Current number of words in the Event FIFO (current depth is 4096)"
                fw_signal="chamber_evtfifos(${OH_IDX}).data_cnt"/>
          <node id="INPUT_FIFO_NEAR_FULL_CNT"  address="0x5"  mask="0x0000ffff" permission="r"
                description="Number of times Input FIFO was near-full (asserted at 75%, deasserted at 50%)"
                fw_signal="input_status_arr(${OH_IDX}).infifo_near_full_cnt"
                sw_monitor_warn_min_threshold="100"/>
          <node id="EVT_FIFO_NEAR_FULL_CNT"  address="0x5"  mask="0xffff0000" permission="r"
                description="Number of times Event FIFO was near-full (asserted at 75%, deasserted at 50%)"
                fw_signal="input_status_arr(${OH_IDX}).evtfifo_near_full_cnt"
                sw_monitor_warn_min_threshold="100"/>
          <node id="VFAT_BLOCK_RATE"  address="0x6"  mask="0x00007fff" permission="r"
                description="Rate of VFAT blocks (192bit words) being written to Input FIFO in Hz (multiply by 192 to get bitrate)"
                fw_signal="input_status_arr(${OH_IDX}).infifo_wr_rate"
                sw_monitor_warn_min_threshold="13000"/>
          <node id="EVT_RATE"  address="0x6"  mask="0xffff8000" permission="r"
                description="Rate of events being written to Event FIFO in Hz"
                fw_signal="input_status_arr(${OH_IDX}).evtfifo_wr_rate"/>
          <node id="MAX_EOE_TIMER"         address="0x7" mask="0x00ffffff" permission="r"
                description="Units = clock cycles @ 160MHz.
                             This indicates the maximum amount of time that event
                             builder took to build and close the event. Note: this is
                             mostly for debugging, most of the time it should be equal
                             to 'End of event timeout'"
                fw_signal="input_status_arr(${OH_IDX}).eb_max_timer"/>
          <node id="LAST_EOE_TIMER"        address="0x8" mask="0x00ffffff" permission="r"
                description="Units = clock cycles @ 160MHz.
                             This shows how long event builder took to build and close
                             the last event. Note: this is mostly for debugging, but could
                             be used to tune the 'end of event timeout'"
                fw_signal="input_status_arr(${OH_IDX}).eb_last_timer"/>
        </node>

        <node id="LASTBLOCK${BLOCK_IDX}"  address="0x9" permission="r"
              description="contains the last 192+32 bits received from the VFAT and OH"
              generate="true" generate_size="7" generate_address_step="0x1" generate_idx_var="BLOCK_IDX"
              fw_signal="input_status_arr(${OH_IDX}).ep_vfat_block_data(${BLOCK_IDX})">
        </node>
      </node>
    </node>

    <!-- OH link module -->
    <node id="OH_LINKS"  address="0x00600000"
          description="OH Link monitoring registers"
          fw_is_module="true"
          fw_module_file="../common/hdl/oh/oh_link_regs.vhd"
          fw_user_clock_signal="clk_i"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="12"
          fw_reg_addr_lsb="0">
      <node id="CTRL" address="0x0"
              description="OH Link control">
        <node id="CNT_RESET" address="0x0" permission="w"
              description="Counter reset"
              fw_write_pulse_signal="reset_local"/>
      </node>

      <node id="OH${OH_IDX}" address="0x100"
            description="Links for OH ${OH_IDX}"
            generate="true" generate_size="12" generate_address_step="0x100" generate_idx_var="OH_IDX">
        <node id="TRACK_LINK_ERROR_CNT" address="0x0" permission="r"
              description="Number of times this link didn't see the correct comma character at the correct time"
              fw_signal="tk_error_cnt_arr(${OH_IDX})"
              sw_monitor_warn_min_threshold="100"/>
        <node id="VFAT_BLOCK_CNT" address="0x1" permission="r"
              description="Number VFAT blocks received"
              fw_signal="evt_rcvd_cnt_arr(${OH_IDX})"/>

        <node id="TRACK_LINK_TX_SYNC_OVF_CNT" address="0x2" permission="r"
              description="Number of overflow occurences in the track tx synchronization FIFO
                           (should be 0, otherwise there's something wrong with clocks)"
              fw_signal="sync_tk_tx_ovf_arr(${OH_IDX})"
              sw_monitor_warn_min_threshold="1"/>
        <node id="TRACK_LINK_TX_SYNC_UNF_CNT" address="0x3" permission="r"
              description="Number of underflow occurences in the track tx synchronization FIFO
                           (should be 0, otherwise there's something wrong with clocks)"
              fw_signal="sync_tk_tx_unf_arr(${OH_IDX})"
              sw_monitor_warn_min_threshold="1"/>
        <node id="TRACK_LINK_RX_SYNC_OVF_CNT" address="0x4" permission="r"
              description="Number of overflow occurences in the track rx synchronization FIFO
                           (should be 0, otherwise there's something wrong with clocks)"
              fw_signal="sync_tk_rx_ovf_arr(${OH_IDX})"
              sw_monitor_warn_min_threshold="1"/>
        <node id="TRACK_LINK_RX_SYNC_UNF_CNT" address="0x5" permission="r"
              description="Number of underflow occurences in the track rx synchronization FIFO
                           (should be 0, otherwise there's something wrong with clocks)"
              fw_signal="sync_tk_rx_unf_arr(${OH_IDX})"
              sw_monitor_warn_min_threshold="1"/>
        <node id="TRIG0_LINK_RX_SYNC_OVF_CNT" address="0x6" permission="r"
              description="Number of overflow occurences in the trigger link0 rx synchronization FIFO
                           (should be 0, otherwise there's something wrong with clocks)"
              fw_signal="sync_tr0_rx_ovf_arr(${OH_IDX})"
              sw_monitor_warn_min_threshold="1"/>
        <node id="TRIG0_LINK_RX_SYNC_UNF_CNT" address="0x7" permission="r"
              description="Number of underflow occurences in the trigger link0 rx synchronization FIFO
                           (should be 0, otherwise there's something wrong with clocks)"
              fw_signal="sync_tr0_rx_unf_arr(${OH_IDX})"
              sw_monitor_warn_min_threshold="1"/>
        <node id="TRIG1_LINK_RX_SYNC_OVF_CNT" address="0x8" permission="r"
              description="Number of overflow occurences in the trigger link1 rx synchronization FIFO
                           (should be 0, otherwise there's something wrong with clocks)"
              fw_signal="sync_tr1_rx_ovf_arr(${OH_IDX})"
              sw_monitor_warn_min_threshold="1"/>
        <node id="TRIG1_LINK_RX_SYNC_UNF_CNT" address="0x9" permission="r"
              description="Number of underflow occurences in the trigger link1 rx synchronization FIFO
                           (should be 0, otherwise there's something wrong with clocks)"
              fw_signal="sync_tr1_rx_unf_arr(${OH_IDX})"
              sw_monitor_warn_min_threshold="1"/>

        <node id="TRACK_LINK_NOT_IN_TABLE_CNT" address="0xa" permission="r"
              description="Number of not-in-table errors in the tracking rx link"
              fw_signal="tk_not_in_table_arr(${OH_IDX})"
              sw_monitor_warn_min_threshold="1000"/>
        <node id="TRACK_LINK_DISPERR_CNT" address="0xb" permission="r"
              description="Number of dispersion errors in the tracking rx link"
              fw_signal="tk_disperr_arr(${OH_IDX})"
              sw_monitor_warn_min_threshold="1000"/>
        <node id="TRIG0_LINK_NOT_IN_TABLE_CNT" address="0xc" permission="r"
              description="Number of not-in-table errors in the trigger link0 rx"
              fw_signal="tr0_not_in_table_arr(${OH_IDX})"
              sw_monitor_warn_min_threshold="1000"/>
        <node id="TRIG0_LINK_DISPERR_CNT" address="0xd" permission="r"
              description="Number of dispersion errors in the trigger link0 rx"
              fw_signal="tr0_disperr_arr(${OH_IDX})"
              sw_monitor_warn_min_threshold="1000"/>
        <node id="TRIG1_LINK_NOT_IN_TABLE_CNT" address="0xe" permission="r"
              description="Number of not-in-table errors in the trigger link1 rx"
              fw_signal="tr1_not_in_table_arr(${OH_IDX})"
              sw_monitor_warn_min_threshold="1000"/>
        <node id="TRIG1_LINK_DISPERR_CNT" address="0xf" permission="r"
              description="Number of dispersion errors in the trigger link1 rx"
              fw_signal="tr1_disperr_arr(${OH_IDX})"
              sw_monitor_warn_min_threshold="1000"/>

      </node>
    </node>

    <!--GEM slow control module -->
    <node id="SLOW_CONTROL"  address="0x00B00000"
          description="This module is handling slow control (mainly OH SCA and OH GBTx IC related communication)"
          fw_is_module="true"
          fw_module_file="../common/hdl/slow_control/slow_control.vhd"
          fw_user_clock_signal="ttc_clk_i.clk_40"
          fw_bus_clock_signal="ipb_clk_i"
          fw_bus_reset_signal="ipb_reset_i"
          fw_master_bus_signal="ipb_mosi_i"
          fw_slave_bus_signal="ipb_miso_o"
          fw_reg_addr_msb="16"
          fw_reg_addr_lsb="0">

      <node id="SCA" address="0x0">
        <node id="CTRL" address="0x0">
          <node id="MODULE_RESET" address="0x0" permission="w"
                description="SCA controller reset (coming out of module reset it will also reset and reconfigure the SCA chip)"
                fw_write_pulse_signal="sca_reset"/>
          <node id="OH_FPGA_HARD_RESET" address="0x1" permission="w"
                description="Writing to this register will trigger OH FPGA hard reset"
                fw_write_pulse_signal="manual_hard_reset"/>
          <node id="TTC_HARD_RESET_EN" address="0x2" mask="0x00000001" permission="rw"
                description="When this is set to 1 (default), TTC hard reset commands are forwarded to the SCA to reset the OH FPGA"
                fw_signal="sca_ttc_hr_enable" fw_default="0b1"/>
        </node>

        <node id="STATUS" address="0x100">
          <node id="READY" address="0x0" mask="0xffffffff" permission="r"
                description="Bits in this register indicate that the SCA controller for the corresponding link has good communication with the SCA chip"
                fw_signal="sca_ready_arr"/>
          <node id="CRITICAL_ERROR" address="0x1" mask="0xffffffff" permission="r"
                description="Bits in this register indicate that the SCA controller for the corresponding link has encountered a critical error (needs reset)"
                fw_signal="sca_critical_error_arr"/>
          <node id="NOT_READY_CNT_OH${OH_IDX}" address="0x2" mask="0x0000ffff" permission="r" 
                description="Counts the number of times that the SCA controller READY signal went to 0 since last SCA reset"
                generate="true" generate_size="12" generate_address_step="0x00000001" generate_idx_var="OH_IDX"
                fw_signal="sca_not_ready_cnt_arr(${OH_IDX})"/>

          <!--node id="RX_ERR_CNT" address="0x1" mask="0x0000ffff" permission="r"
                description="Number of RX errors"
                fw_signal="sca_rx_err_cnt"/>
          <node id="SEQ_NUM_ERR_CNT" address="0x1" mask="0xffff0000" permission="r"
                description="Number of sequence number errors"
                fw_signal="sca_seq_num_err_cnt"/>
          <node id="CRC_ERR_CNT" address="0x2" mask="0x0000ffff" permission="r"
                description="Number of CRC errors"
                fw_signal="sca_crc_err_cnt"/>
          <node id="TRANSACTION_TIMEOUT_CNT" address="0x2" mask="0xffff0000" permission="r"
                description="Number of transaction timeouts"
                fw_signal="sca_tr_timeout_cnt"/>
          <node id="TRANSACTION_FAIL_CNT" address="0x3" mask="0x0000ffff" permission="r"
                description="Number of transaction failures (all retries used up)"
                fw_signal="sca_tr_fail_cnt"/>
          <node id="LAST_SCA_ERROR" address="0x3" mask="0x007f0000" permission="r"
                description="Last error reported by the SCA chip"
                fw_signal="sca_last_sca_error"/>
          <node id="TRANSACTION_DONE_CNT" address="0x4" permission="r"
                description="Number of transactions successfully executed"
                fw_signal="sca_tr_done_cnt"/-->
        </node>

        <node id="MANUAL_CONTROL" address="0x1000">
          <node id="LINK_ENABLE_MASK" address="0x0" mask="0xffffffff" permission="rw"
                description="This is a bitmask of enabled links for the SCA manual command.
                             Multiple channels can be enabled at the same time, which will 
                             result in a broadcast command to these channels when writing to the command registers"
                fw_signal="sca_user_command_en_mask" fw_default="0x00000000"/>
 
          <node id="SCA_CMD" address="0x1">
            <node id="SCA_CMD_CHANNEL" address="0x0" mask="0x000000ff" permission="rw"
                  description="Manual SCA command: channel"
                  fw_signal="sca_user_command.channel" fw_default="0x00"/>
            <node id="SCA_CMD_COMMAND" address="0x0" mask="0x0000ff00" permission="rw"
                  description="Manual SCA command: command"
                  fw_signal="sca_user_command.command" fw_default="0x00"/>
            <node id="SCA_CMD_LENGTH" address="0x0" mask="0x00ff0000" permission="rw"
                  description="Manual SCA command: length (range = 0 to 4)"
                  fw_signal="sca_user_command.length" fw_default="0x00"/>
            <node id="SCA_CMD_DATA" address="0x1" permission="rw"
                  description="Manual SCA command: data"
                  fw_signal="sca_user_command.data" fw_default="0x00000000"/>
            <node id="SCA_CMD_EXECUTE" address="0x2" permission="w"
                  description="Manual SCA command: writing to this register will trigger the execution of the SCA command"
                  fw_write_pulse_signal="sca_user_command_en" fw_write_done_signal="sca_user_command_done_all"/>
          </node>

          <node id="SCA_REPLY_OH${OH_IDX}" address="0x4"
                description="SCA reply for Optohybrid ${OH_IDX}"
                generate="true" generate_size="12" generate_address_step="0x00000002" generate_idx_var="OH_IDX">

            <node id="SCA_RPY_CHANNEL" address="0x0" mask="0x000000ff" permission="r"
                  description="SCA reply to the manual command: channel"
                  fw_signal="sca_user_reply_arr(${OH_IDX}).channel"/>
            <node id="SCA_RPY_ERROR" address="0x0" mask="0x0000ff00" permission="r"
                  description="SCA reply to the manual command: command"
                  fw_signal="sca_user_reply_arr(${OH_IDX}).error"/>
            <node id="SCA_RPY_LENGTH" address="0x0" mask="0x00ff0000" permission="r"
                  description="SCA reply to the manual command: length (range = 0 to 4)"
                  fw_signal="sca_user_reply_arr(${OH_IDX}).length"/>
            <node id="SCA_RPY_DATA" address="0x1" permission="r"
                  description="SCA reply to the manual command: data"
                  fw_signal="sca_user_reply_arr(${OH_IDX}).data"/>
          </node>
        </node>

        <node id="ADC_MONITORING" address="0x2000">
          <node id="MONITORING_OFF" address="0x0" mask="0xffffffff" permission="rw"
                description="Bits corresponding to each link if set to 1 will suspend ADC monitoring on that SCA"
                fw_signal="sca_adc_monitor_off_arr" fw_default="0x00000000"/>

          <node id="OH${OH_IDX}" address="0x1"
                description="ADC monitoring of Optohybrid ${OH_IDX}"
                generate="true" generate_size="12" generate_address_step="0x0000000f" generate_idx_var="OH_IDX">

            <node id="AVCCN" address="0x0" mask="0x00000fff" permission="r"
                  description="AVCCN voltage"
                  fw_signal="sca_adc_readings_arr(${OH_IDX})(0)"/>
            <node id="AVTTN" address="0x0" mask="0x00fff000" permission="r"
                  description="AVTTN voltage"
                  fw_signal="sca_adc_readings_arr(${OH_IDX})(1)"/>
            <node id="1V0_INT" address="0x1" mask="0x00000fff" permission="r"
                  description="1.0V INT voltage"
                  fw_signal="sca_adc_readings_arr(${OH_IDX})(2)"/>
            <node id="1V8F" address="0x1" mask="0x00fff000" permission="r"
                  description="1.8V F voltage"
                  fw_signal="sca_adc_readings_arr(${OH_IDX})(3)"/>
            <node id="1V5" address="0x2" mask="0x00000fff" permission="r"
                  description="1.5V voltage"
                  fw_signal="sca_adc_readings_arr(${OH_IDX})(4)"/>
            <node id="2V5_IO" address="0x2" mask="0x00fff000" permission="r"
                  description="2.5V IO voltage"
                  fw_signal="sca_adc_readings_arr(${OH_IDX})(5)"/>
            <node id="3V0" address="0x3" mask="0x00000fff" permission="r"
                  description="3.0V voltage"
                  fw_signal="sca_adc_readings_arr(${OH_IDX})(6)"/>
            <node id="1V8" address="0x3" mask="0x00fff000" permission="r"
                  description="1.8V voltage"
                  fw_signal="sca_adc_readings_arr(${OH_IDX})(7)"/>
            <node id="VTRX_RSSI2" address="0x4" mask="0x00000fff" permission="r"
                  description="VTRX RSSI2 voltage"
                  fw_signal="sca_adc_readings_arr(${OH_IDX})(8)"/>
            <node id="VTRX_RSSI1" address="0x4" mask="0x00fff000" permission="r"
                  description="VTRX RSSI1 voltage"
                  fw_signal="sca_adc_readings_arr(${OH_IDX})(9)"/>
            <node id="SCA_TEMP" address="0x5" mask="0x00000fff" permission="r"
                  description="SCA Temperature"
                  fw_signal="sca_adc_readings_arr(${OH_IDX})(10)"/>
            <node id="BOARD_TEMP1" address="0x5" mask="0x00fff000" permission="r"
                  description="Board Temperature Sensor #1"
                  fw_signal="sca_adc_readings_arr(${OH_IDX})(11)"/>
            <node id="BOARD_TEMP2" address="0x6" mask="0x00000fff" permission="r"
                  description="Board Temperature Sensor #2"
                  fw_signal="sca_adc_readings_arr(${OH_IDX})(12)"/>
            <node id="BOARD_TEMP3" address="0x6" mask="0x00fff000" permission="r"
                  description="Board Temperature Sensor #3"
                  fw_signal="sca_adc_readings_arr(${OH_IDX})(13)"/>
            <node id="BOARD_TEMP4" address="0x7" mask="0x00000fff" permission="r"
                  description="Board Temperature Sensor #4"
                  fw_signal="sca_adc_readings_arr(${OH_IDX})(14)"/>
            <node id="BOARD_TEMP5" address="0x7" mask="0x00fff000" permission="r"
                  description="Board Temperature Sensor #5"
                  fw_signal="sca_adc_readings_arr(${OH_IDX})(15)"/>
            <node id="BOARD_TEMP6" address="0x8" mask="0x00000fff" permission="r"
                  description="Board Temperature Sensor #6"
                  fw_signal="sca_adc_readings_arr(${OH_IDX})(16)"/>
            <node id="BOARD_TEMP7" address="0x8" mask="0x00fff000" permission="r"
                  description="Board Temperature Sensor #7"
                  fw_signal="sca_adc_readings_arr(${OH_IDX})(17)"/>
            <node id="BOARD_TEMP8" address="0x9" mask="0x00000fff" permission="r"
                  description="Board Temperature Sensor #8"
                  fw_signal="sca_adc_readings_arr(${OH_IDX})(18)"/>
            <node id="BOARD_TEMP9" address="0x9" mask="0x00fff000" permission="r"
                  description="Board Temperature Sensor #9"
                  fw_signal="sca_adc_readings_arr(${OH_IDX})(19)"/>
          </node>
        </node>

        <node id="JTAG" address="0x2500">
          <node id="CTRL" address="0x0">
            <node id="ENABLE_MASK" address="0x0" mask="0xffffffff" permission="rw"
                  description="This is a bitmask of enabled links for the SCA JTAG commands.
                               Multiple channels can be enabled at the same time, which will 
                               result in a broadcast command to these channels when writing to the TDO and TMS registers"
                  fw_signal="jtag_enabled_mask" fw_default="0x00000000"/>
            <node id="SHIFT_MSB" address="0x1" mask="0x00000002" permission="rw"
                  description="If this is 1 then SCA will shift out bits MSB to LSB and if this is 0 then LSB to MSB (default)"
                  fw_signal="jtag_shift_msb_first" fw_default="0b0"/>
            <node id="EXPERT" address="0x1">
              <node id="EXEC_ON_EVERY_TDO" address="0x0" mask="0x00000004" permission="rw"
                    description="EXPERT ONLY: used to optimize firmware downloading, when set high the controller will execute
                                 JTAG_GO after every TDO shift (even if length is higher than 32)"
                    fw_signal="jtag_exec_on_every_tdo" fw_default="0b0"/>
              <node id="NO_SCA_LENGTH_UPDATE" address="0x0" mask="0x00000008" permission="rw"
                    description="EXPERT ONLY: used to optimize firmware downloading, when set high the controller will
                                 assume that SCA already has the correct length and will not update it before each JTAG_GO"
                    fw_signal="jtag_no_length_update" fw_default="0b0"/>
              <node id="SHIFT_TDO_ASYNC" address="0x0" mask="0x00000010" permission="rw"
                    description="kindof expert: if this is set high then JTAG controller will acknowledge the TDO shift
                                 command immediately, but if the second command is received while it's still busy it
                                 won't assert jtag_shift_done_o until the previous command is done"
                    fw_signal="jtag_shift_tdo_async" fw_default="0b0"/>
            </node>
          </node>
          <node id="NUM_BITS" address="0x2" mask="0x000007f" permission="rw"
                description="Number of bits in the JTAG command (0 means 128). Once you shift this number of bits of
                             TDO data, the JTAG command will be executed and TDI is available for reading"
                fw_signal="jtag_cmd_length" fw_default="0b0000000"/>
          <node id="TMS" address="0x3" permission="w"
                description="TMS bits to shift to the SCA chip. 32 bits are shifted with each write to this register.
                             The write transaction completes once the bit shifting to the SCA is already done and
                             confirmed by the SCA, so there's no need to sleep between the consecutive writes to this register."
                fw_signal="jtag_tms" fw_write_pulse_signal="jtag_shift_tms_en" fw_write_done_signal="jtag_shift_done_all"
                fw_default="0x00000000"/>
          <node id="TDO" address="0x4" permission="w"
                description="TDO bits to shift to the SCA chip. 32 bits are shifted with each write to this register.
                             Once the number of bits shifted is equal to or greater than the NUM_BITS the JTAG command
                             will be executed. The write transaction completes once the bit shifting to the SCA is
                             already done and confirmed by the SCA, so there's no need to sleep between the consecutive
                             writes to this register."
                fw_signal="jtag_tdo" fw_write_pulse_signal="jtag_shift_tdo_en" fw_write_done_signal="jtag_shift_done_all"
                fw_default="0x00000000"/>

          <node id="TDI_OH${OH_IDX}" address="0x5" permission="r"
                description="When reading this register the TDI bits are shifted from the SCA of OH${OH_IDX} (32 bits with each read)."
                generate="true" generate_size="12" generate_address_step="0x00000001" generate_idx_var="OH_IDX"
                fw_signal="jtag_tdi_arr(${OH_IDX})" fw_read_pulse_signal="jtag_shift_tdi_en_arr(${OH_IDX})" fw_read_ready_signal="jtag_shift_done_arr(${OH_IDX})"/>
        </node>

        <!--node id="DEBUG" address="0x3000">
          <node id="RAW_TX_LAST_CMD_0" address="0x0" permission="r"
                description="Last raw output on the TX, bits [31:0]"
                fw_signal="sca_tx_raw_last_cmd(31 downto 0)"/>
          <node id="RAW_TX_LAST_CMD_1" address="0x1" permission="r"
                description="Last raw output on the TX, bits [63:32]"
                fw_signal="sca_tx_raw_last_cmd(63 downto 32)"/>
          <node id="RAW_TX_LAST_CMD_2" address="0x2" permission="r"
                description="Last raw output on the TX, bits [95:64]"
                fw_signal="sca_tx_raw_last_cmd(95 downto 64)"/>
          <node id="RAW_RX_LAST_RPY_0" address="0x3" permission="r"
                description="Last raw input on the RX, bits [31:0]"
                fw_signal="sca_rx_raw_last_reply(31 downto 0)"/>
          <node id="RAW_RX_LAST_RPY_1" address="0x4" permission="r"
                description="Last raw input on the RX, bits [63:32]"
                fw_signal="sca_rx_raw_last_reply(63 downto 32)"/>
          <node id="RAW_RX_LAST_RPY_2" address="0x5" permission="r"
                description="Last raw input on the RX, bits [95:64]"
                fw_signal="sca_rx_raw_last_reply(95 downto 64)"/>
          <node id="RX_LAST_CALC_CRC" address="0x6" mask="0x0000ffff" permission="r"
                description="RX last calculated CRC"
                fw_signal="sca_rx_last_calc_crc"/>
        </node-->

      </node>

      <node id="IC" address="0x10000">
        <node id="ADDRESS" address="0x0" mask="0x0000ffff" permission="rw"
              description="GBTx register address to read or write"
              fw_signal="ic_address" fw_default="0x0000"/>
        <node id="READ_WRITE_LENGTH" address="0x1" mask="0x00000007" permission="rw"
              description="Number of data bytes to be written or read e.g. if you set it to 4 then 4 consecutive
                           GBTx registers will be written with the 4 bytes in WRITE_DATA register. Max is 4."
              fw_signal="ic_rw_length" fw_default="0x01"/>
        <node id="WRITE_DATA" address="0x2" permission="rw"
              description="GBTx register value to write"
              fw_signal="ic_write_data" fw_default="0x00"/>
        <node id="EXECUTE_WRITE" address="0x3" permission="w"
              description="writing any value here will execute a GBTx register write operation"
              fw_write_pulse_signal="ic_write_req" fw_write_done_signal="ic_write_done"/>
        <node id="EXECUTE_READ" address="0x4" permission="w"
              description="writing any value here will execute a GBTx register read operation"
              fw_write_pulse_signal="ic_read_req"/>
        <node id="GBTX_I2C_ADDR" address="0x5" mask="0x0000000f" permission="rw"
              description="GBTx I2C address as defined by the I2CADDRESS pins of the GBTx chip"
              fw_signal="ic_gbtx_i2c_addr" fw_default="0x1"/>
      </node>

    </node>

    <!--OptoHybrid module -->
    <node id="OH"  address="0x00400000"
          description="Optohybrid Registers"
          fw_is_module="true"
          fw_is_module_external="true">

      <node id="OH${OH_IDX}"  address="0x0"
            description="Optohybrid ${OH_IDX}"
            generate="true" generate_size="12" generate_address_step="0x00010000" generate_idx_var="OH_IDX">

        <node id="COUNTERS"  address="0xa000"
              description="Counters provided on the OptoHybrid">

          <node id="CRC"  address="0x24"
                description="Counters related to the VFAT CRC values">
            <node id="VALID"      address="0x0"
                  description="Counter for each VFAT number of data packets with valid CRC">
              <node id="VFAT${VFAT_IDX}"   address="0x00"  permission="r"
                    description="CRC counters for the tracking data for VFAT${VFAT_IDX}"
                    generate="true" generate_size="24" generate_address_step="0x1" generate_idx_var="VFAT_IDX">
                <node id="Reset"  address="0x0"  permission="w"
                      description="write any value to the register to reset the counter
                                   Use mask to only allow writing to the first bit"/>
              </node>
            </node>

            <node id="INCORRECT" address="0x18"
                  description="Counter for each VFAT number of data packets with incorrect CRC">
              <node id="VFAT${VFAT_IDX}"   address="0x00"  permission="r"
                    description="CRC counters for the tracking data for VFAT${VFAT_IDX}"
                    generate="true" generate_size="24" generate_address_step="0x1" generate_idx_var="VFAT_IDX">
                <node id="Reset"  address="0x0"  permission="w"
                      description="write any value to the register to reset the counter
                                   Use mask to only allow writing to the first bit"/>
              </node>
            </node>
          </node>

          <node id="WB"  address="0x00"
                description="Counters related to the OptoHybrid wishbone">
            <node id="MASTER"  address="0x0">
              <node id="Strobe"  address="0x0"
                    description="">
                <node id="GTX"      address="0x0"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="GBT"      address="0x6D"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="ExtI2C"   address="0x1"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="Scan"     address="0x2"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="DAC"      address="0x3"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>
              </node>
              <node id="Ack"  address="0x4"
                    description="">
                <node id="GTX"      address="0x0"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="GBT"      address="0x6A"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="ExtI2C"   address="0x1"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="Scan"     address="0x2"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="DAC"      address="0x3"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>
              </node>
            </node>

            <node id="SLAVE"  address="0x8"
                  description="">
              <node id="Strobe"  address="0x0"
                    description="">
                <node id="I2C${I2C_IDX}"   address="0x00"  permission="r"
                      description="Strobe counters for I2C${I2C_IDX}"
                      generate="true" generate_size="6" generate_address_step="0x1" generate_idx_var="I2C_IDX">
                  <node id="Reset"  address="0x0"  permission="w" />
                </node>

                <node id="ExtI2C"   address="0x6"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="Scan"     address="0x7"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="T1"       address="0x8"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="DAC"       address="0x9"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="ADC"       address="0xa"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="Clocking"  address="0xb"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="Counters"  address="0xc"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="System"    address="0xd"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>
              </node>
              <node id="Ack"  address="0xe"
                    description="">
                <node id="I2C${I2C_IDX}"   address="0x00"  permission="r"
                      description="Acknowledge counters for I2C${I2C_IDX}"
                      generate="true" generate_size="6" generate_address_step="0x1" generate_idx_var="I2C_IDX">
                  <node id="Reset"  address="0x0"  permission="w" />
                </node>

                <node id="ExtI2C"   address="0x6"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="Scan"     address="0x7"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="T1"       address="0x8"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="DAC"       address="0x9"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="ADC"       address="0xa"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="Clocking"  address="0xb"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="Counters"  address="0xc"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>

                <node id="System"    address="0xd"  permission="r">
                  <node id="Reset"  address="0x0"  permission="w"/>
                </node>
              </node>
            </node>
          </node>

          <node id="T1"  address="0x54"
                description="Counters related to the OptoHybrid T1 signals">
            <node id="GTX_TTC"    address="0x00"
                  description="T1 signals received from the AMC over the 8b10b fiber link">
              <node id="L1A"      address="0x0"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
              <node id="CalPulse" address="0x1"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
              <node id="Resync"   address="0x2"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
              <node id="BC0"      address="0x3"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
            </node>

            <node id="GBT_TTC"    address="0x1b"
                  description="T1 signals received from the AMC over the GBT link">
              <node id="L1A"      address="0x0"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
              <node id="CalPulse" address="0x1"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
              <node id="Resync"   address="0x2"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
              <node id="BC0"      address="0x3"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
            </node>

            <node id="INTERNAL"  address="0x04"
                  description="T1 signals generated by the OptoHybrid firmware">
              <node id="L1A"      address="0x0"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
              <node id="CalPulse" address="0x1"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
              <node id="Resync"   address="0x2"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
              <node id="BC0"      address="0x3"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
            </node>

            <node id="EXTERNAL"  address="0x08"
                  description="T1 signals recieved from an external source">
              <node id="L1A"      address="0x0"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
              <node id="CalPulse" address="0x1"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
              <node id="Resync"   address="0x2"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
              <node id="BC0"      address="0x3"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
            </node>

            <node id="LOOPBACK"  address="0x0c"
                  description="T1 signals sent in loopback mode">
              <node id="L1A"      address="0x0"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
              <node id="CalPulse" address="0x1"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
              <node id="Resync"   address="0x2"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
              <node id="BC0"      address="0x3"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
            </node>

            <node id="SENT"      address="0x10"
                  description="T1 signals sent to the GEB (VFATs)">
              <node id="L1A"      address="0x0"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
              <node id="CalPulse" address="0x1"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
              <node id="Resync"   address="0x2"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
              <node id="BC0"      address="0x3"  permission="r">
                <node id="Reset"  address="0x0"  permission="w"/>
              </node>
            </node>
          </node>

          <node id="GTX_LINK"  address="0x68"
                description="Counters related to the OptoHybrid GTX optical links">
            <node id="TRK_ERR"   address="0x0"  permission="r"
                  description="Error counter on the tracking data optical link">
              <node id="Reset"  address="0x0"  permission="w"/>
            </node>

            <node id="TRG_ERR"   address="0x1"  permission="r"
                  description="Error counter on the trigger data optical link (OBSOLETE)">
              <node id="Reset"  address="0x0"  permission="w"/>
            </node>

            <node id="DATA_Packets"   address="0x2"  permission="r"
                  description="Number of received data packets counter on the optical link">
              <node id="Reset"  address="0x0"  permission="w"/>
            </node>
          </node>

          <node id="QPLL_LOCK"           address="0x6B"  permission="rw">
            <node id="Reset"  address="0x0"  permission="w"/>
          </node>
          <node id="QPLL_FPGA_PLL_LOCK"  address="0x6C"  permission="rw">
            <node id="Reset"  address="0x0"  permission="w"/>
          </node>

          <node id="GBT_LINK"  address="0x6D"
                description="Counters related to the OptoHybrid GBT optical links">

            <!-- GBT WB counters are in the WB counters block-->
            <!-- <node id="WB_STROBE"   address="0x0"  permission="r" -->
            <!--       description="Error counter on the tracking data optical link"> -->
            <!--   <node id="Reset"  address="0x0"  permission="w"/> -->
            <!-- </node> -->

            <!-- <node id="WB_ACK"   address="0x1"  permission="r" -->
            <!--       description="Error counter on the trigger data optical link"> -->
            <!--   <node id="Reset"  address="0x0"  permission="w"/> -->
            <!-- </node> -->

            <!-- GBT T1 counters are in the T1 counters block-->
            <!-- <node id="T1"   address="0x2"  permission="r" -->
            <!--       description="Error counter on the trigger data optical link"> -->
            <!--   <node id="Reset"  address="0x0"  permission="w"/> -->
            <!-- </node> -->

            <node id="TRK_ERR"   address="0x6"  permission="r"
                  description="Number of errors on the GBT optical link">
              <node id="Reset"  address="0x0"  permission="w"/>
            </node>

            <node id="DATA_Packets"   address="0x7"  permission="r"
                  description="Number of received data packets counter on the optical link">
              <node id="Reset"  address="0x0"  permission="w"/>
            </node>
          </node>

          <node id="RATES"  address="0x75"
                description="Rate counter registers">
            <node id="TIMER"  address="0x0"  permission="r"
                  description="Timer for the rate counter">
              <node id="RESET"  address="0x0"  permission="w"/>
            </node>

            <node id="TRG_HITS"  address="0x1"
                  description="Hit counters for the trigger data from each VFAT">
              <node id="VFAT${VFAT_IDX}"   address="0x00"  permission="r"
                    description="Trigger data hit counter for VFAT${VFAT_IDX}"
                    generate="true" generate_size="24" generate_address_step="0x1" generate_idx_var="VFAT_IDX">
                <node id="RESET"  address="0x0"  permission="w"/>
              </node>
            </node>

            <node id="TRK_HITS"  address="0x19"
                  description="Hit counters for the tracking data from each VFAT">
              <node id="VFAT${VFAT_IDX}"   address="0x00"  permission="r"
                    description="Tracking data hit counter for VFAT${VFAT_IDX}"
                    generate="true" generate_size="24" generate_address_step="0x1" generate_idx_var="VFAT_IDX">
                <node id="RESET"  address="0x0"  permission="w"/>
              </node>
            </node>
          </node>

          <node id="SEU"  address="0xa6"  permission="r"
                description="Rate counter registers">
            <node id="RESET"  address="0x0"  permission="w"/>
          </node>
          <node id="VFAT${VFAT_IDX}_LAT_BX"  address="0xa7"  permission="r"
                description="Rate counter registers"
                generate="true" generate_size="24" generate_address_step="0x1" generate_idx_var="VFAT_IDX">
            <node id="RESET"  address="0x0"  permission="w"/>
          </node>
        </node> <!-- end of COUNTERS -->


        <node id="CONTROL"  address="0xb000"
              description="Control registers of the OptoHybrid">
          <node id="VFAT"  address="0x0"  permission="rw"
	        description="Control on the OptoHybrid related to the VFATs">
            <node id="TRK_MASK"  address="0x0"  mask="0x00ffffff"  permission="rw"
                  description="Masks individual VFATs from sending tracking data packets"/>
            <node id="RESET"  address="0x3"  permission="w"
                  description="Returns to a 0 state"/>
            <node id="SBIT_MASK"  address="0x4"  mask="0x00ffffff"  permission="rw"
	          description="Mask to block individual VFATs from sending s-bits data"/>
            <node id="DROP_BAD_CRC"  address="0xa"  mask="0x1"  permission="rw"
	          description="Remove data with bad CRC
                               0 : keep all the data
                               1 : ignore data with a bad CRC"/>
          </node>

          <node id="TRIGGER" address="0x1" permission="rw"
                description="Trigger options for the OptoHybrid">
            <node id="SOURCE"  address="0x0"  mask="0x7"  permission="rw"
                  description="Selects the source of T1 signals sent to the GEB (3 bits [0,5]:
                               0: T1 from AMC TTC decoder over backplane (GTX, AMC13)
                               1: T1 from OptoHybrid firmware
                               2: T1 from external source
                               3: Internal loopback on S-bits
                               4: Logical OR of all sources
                               5: T1 from AMC TTC decoder over backplane (GBT, AMC13)"/>
            <node id="LOOPBACK"  address="0x1"  mask="0x1f"  permission="rw"
                  description="Selects the S-bit source to loop back  (5 bits)"/>
            <node id="THROTTLE"  address="0x5"   permission="rw"
	          description="Throttle the triggers sent to the GEB "/>
          </node>

          <node id="HDMI_OUTPUT"  address="0x5"  permission="rw"
	        description="Control on the OptoHybrid related to the s-bits sent out">
            <node id="SBITS"  address="0x0"  permission="rw"
                  description="Select the s-bit sources to send out, depends on the mode ">
              <node id="OUT_0"  address="0x0"  mask="0x0000001f"  permission="rw"/>
              <node id="OUT_1"  address="0x0"  mask="0x000003e0"  permission="rw"/>
              <node id="OUT_2"  address="0x0"  mask="0x00007c00"  permission="rw"/>
              <node id="OUT_3"  address="0x0"  mask="0x000f8000"  permission="rw"/>
              <node id="OUT_4"  address="0x0"  mask="0x001f0000"  permission="rw"/>
              <node id="OUT_5"  address="0x0"  mask="0x03e00000"  permission="rw"/>
            </node>
            <node id="SBIT_MODE"  address="0x3"  mask="0x00000003"  permission="rw"
	          description="Mode to select s-bits out on the HDMI connector
                               0: OUT[0-5] correspond to individaul VFATs [0-23]
                               1: OUT[0-5] correspond to iEta sectors [0-7]]
                               2: OUT[0-5] correspond to I2C sectors (automatically selected)
                               3: OUT[0-5] are constant 0"/>
          </node>

          <node id="ZS"  address="0x7"  mask="0x00000001"  permission="rw"
	        description="Enable/disable zero-suppression"/>

          <node id="CLOCK"  address="0x9"  permission="rw"
                description="Control on the OptoHybrid related to the clocking">
            <node id="REF_CLK"  address="0x0"  mask="0x1"  permission="rw"
                  description="Select the reference clock source (1 bit):
                               0: QPLL
                               1: GBT recovered clock"/>
          </node>
        </node> <!-- end of CONTROL -->

        <node id="STATUS"  address="0xc000"
              description="Status registers of the OptoHybrid">

          <node id="FW"  address="0x0"  permission="r"
	        description="Firmware version on the OH">
            <node id="DATE"  address="0x0"  permission="r"
	          description="Firmware date string on the OH"/>
            <node id="VERSION"  address="0x3"  permission="r"
	          description="Firmware version on the OH">
              <node id="MAJOR"  mask="0xff000000"    permission="r"/>
              <node id="MINOR"  mask="0x00ff0000"    permission="r"/>
              <node id="BUILD"  mask="0x0000ff00"    permission="r"/>
              <node id="PATCH"  mask="0x000000ff"    permission="r"/>
            </node>
          </node>

          <!-- registers only in V2A -->
          <node id="FPGA_PLL_LOCK"  address="0x1"  mask="0x1"  permission="r"
                description="Returns the lock status of the FPGA clock PLL"/>
          <node id="EXT_PLL_LOCK"   address="0x2"  mask="0x1"  permission="r"
                description="Returns the lock status of the external clock PLL"/>
          <node id="CDCE_LOCK"      address="0x3"  mask="0x1"  permission="r"
                description="Returns the lock status of the CDCE"/>
          <node id="GTX_LOCK"       address="0x4"  mask="0x1"  permission="r"
                description="Returns the lock status of the recovered clock (GTX)"/>

          <!-- registers only in V2B -->
          <node id="QPLL_LOCK"            address="0x1"  mask="0x1"  permission="r"
                description="Returns the lock status of the QPLL"/>
          <node id="QPLL_FPGA_PLL_LOCK"   address="0x2"  mask="0x1"  permission="r"
                description="Returns the lock status of the QPLL to FPGA clock PLL"/>

          <node id="SEU"  address="0x4"  mask="0x1"  permission="r"
                description="0: no critical errors due to SEU
                             1: critical error detected, due to SEU"/>
        </node> <!-- end of STATUS -->

        <node id="T1Controller"  address="0x3000"
              description="T1 controller provided on the OptoHybrid">

          <node id="TOGGLE" address="0x0"  permission="w"
                description="Toggle the T1 controller on/off"/>
          <node id="MODE"   address="0x1"  mask="0x7"  permission="rw"
                description="3 bits to select the mode:
                             0: Send N T1 commands of type type with an interval of interval BXs.
                             1: Send N packets composed of a Calpulse followed by an LV1A separated by delay BXs.
                             2: Send T1 commands according to a pattern defined by the sequence registers"/>

          <node id="TYPE" address="0x2"  mask="0xf" permission="rw"
                description="4 bits to select the type of T1 signal (only for mode 0 and 1)
                             0: L1A
                             1: CalPulse
                             2: Resync
                             3: BC0"/>
          <node id="NUMBER"   address="0x3"   permission="rw"
                description="Number of repetitions to send (only for mode 0 and 1)
                             default is 0 = infinite"/>
          <node id="INTERVAL" address="0x4"   permission="rw"
                description="How many BX between signals (only for mode 0 and 1)
                             Minimum 3"/>
          <node id="DELAY"   address="0x5"   permission="rw"
                description="Number of clock cycles between CalPulse and L1A (only for mode 1).
                             Between 3 clock cycles and INTERVAL - 3 clock cycles "/>

          <node id="Sequence"  address="0x6"  permission="rw"
                description="Define sequences of signals to generate (only for mod 2),
                             64 bit patterns for each signal">

            <node id="L1A"       address="0x0"  permission="rw"
                  description="L1A sequence to generate">
              <node id="LSB"  address="0x0"   permission="rw"/>
              <node id="MSB"  address="0x1"   permission="rw"/>
            </node>
            <node id="CalPulse"  address="0x2"  permission="rw"
                  description="CalPulse sequence to generate">
              <node id="LSB"  address="0x0"   permission="rw"/>
              <node id="MSB"  address="0x1"   permission="rw"/>
            </node>
            <node id="Resync"    address="0x4"  permission="rw"
                  description="Resyc sequence to generate">
              <node id="LSB"  address="0x0"   permission="rw"/>
              <node id="MSB"  address="0x1"   permission="rw"/>
            </node>
            <node id="BC0"       address="0x6"  permission="rw"
                  description="BC0 sequence to generate">
              <node id="LSB"  address="0x0"   permission="rw"/>
              <node id="MSB"  address="0x1"   permission="rw"/>
            </node>
          </node>

          <node id="MONITOR"    address="0xe"  mask="0xf"  permission="rw"
                description="Status monitor for the T1 controller (4 bits):
                             0: nothing running
                             1: mode 1 running
                             2: mode 2 running
                             3: mode 3 running"/>
          <node id="RESET"    address="0xf"   permission="w"
                description="T1 controller reset"/>
        </node> <!-- end of T1CONTROLLER -->

        <node id="ADC"  address="0x8000"
              description="ADC provided on the OptoHybrid">
          <node id="TEMP"  address="0x0"  permission="r"
                description="Returns the value from the ADC temperature
                             The 10 MSBs correspond to the ADC transfer function. 1 LSB corresponds to 0.49 C">
            <node id="MAX"    address="0x20"  permission="r"
                  description="Returns the maximum seen temperature value
                               The 10 MSBs correspond to the ADC transfer function. 1 LSB corresponds to 0.49 C"/>
            <node id="MIN"    address="0x24"  permission="r"
                  description="Returns the minimum seen temperature value
                               The 10 MSBs correspond to the ADC transfer function. 1 LSB corresponds to 0.49 C"/>
          </node>
          <node id="VCCINT"  address="0x1"  permission="r"
                description="Returns the value from the ADC VCC int
                             The 10 MSBs correspond to the ADC transfer function. 1 LSB corresponds to 2.93 mV">
            <node id="MAX"    address="0x20"  permission="r"
                  description="Returns the maximum seen VCC int value
                               The 10 MSBs correspond to the ADC transfer function. 1 LSB corresponds to 2.93 mV"/>
            <node id="MIN"    address="0x24"  permission="r"
                  description="Returns the minimum seen VCC int value
                               The 10 MSBs correspond to the ADC transfer function. 1 LSB corresponds to 2.93 mV"/>
          </node>
          <node id="VCCAUX"  address="0x2"  permission="r"
                description="Returns the value from the ADC VCC aux
                             The 10 MSBs correspond to the ADC transfer function. 1 LSB corresponds to 2.93 mV">
            <node id="MAX"    address="0x20"  permission="r"
                  description="Returns the maximum seen VCC aux value
                               The 10 MSBs correspond to the ADC transfer function. 1 LSB corresponds to 2.93 mV"/>
            <node id="MIN"    address="0x24"  permission="r"
                  description="Returns the minimum seen VCC aux value
                               The 10 MSBs correspond to the ADC transfer function. 1 LSB corresponds to 2.93 mV"/>
          </node>
          <node id="VPVN"  address="0x3"  permission="r"
                description="Returns the value from the ADC VPVN
                             The 10 MSBs correspond to the ADC transfer function"/>
          <node id="VREFP"  address="0x4"  permission="r"
                description="The result of a conversion on the reference input VREFP is stored in this register. The
                             10 MSBs correspond to the ADC transfer function shown in Figure 6. The supply sensor
                             is used when measuring VREFP .This channel is also used during a calibration (see System
                             Monitor Calibration, page 31)."/>
          <node id="VREFN"  address="0x5"  permission="r"
                description="The result of a conversion on the reference input VREFN is stored in this register. The
                             10 MSBs correspond to the ADC transfer function shown in Figure 6. The supply sensor
                             is used when measuring VREFP . This channel is also used during a calibration (see System
                             Monitor Calibration, page 31)."/>
          <node id="SUPPLY_OFFSET"  address="0x8"  permission="r"
                description="The calibration coefficient for the supply sensor offset is stored at this location (see System
                             Monitor Calibration, page 31)
                             The offset correction factor is a 10-bit, two's complement number, MSB justified.">
            <node id="MAGNITUDE"  address="0x0"  mask="0x7fc0" permission="r"
                  description="These nine bits store the magnitude information for the gain correction factor.
                               1 LSB corresponds to 3 mV"/>
            <node id="SIGN"  address="0x0"  mask="0x8000" permission="r"
                  description="If this bit is a logic 1, then the correction factor is positive, corresponding to MAGNITUDE.
                               If it is 0, then the correction factor is negative, corresponding to -(!(MAGNITUDE)+1)"/>
          </node>
          <node id="ADC_OFFSET"  address="0x9"  permission="r"
                description="The calibration coefficient for the ADC offset calibration is stored at this location (see
                             System Monitor Calibration, page 31)
                             The offset correction factor is a 10-bit, two's complement number, MSB justified.">
            <node id="MAGNITUDE"  address="0x0"  mask="0x7fc0" permission="r"
                  description="These nine bits store the magnitude information for the gain correction factor.
                               1 LSB corresponds to 3 mV"/>
            <node id="SIGN"  address="0x0"  mask="0x8000" permission="r"
                  description="If this bit is a logic 1, then the correction factor is positive, corresponding to MAGNITUDE.
                               If it is 0, then the correction factor is negative, corresponding to -(!(MAGNITUDE)+1)"/>
          </node>
          <node id="ADC_GAIN_ERROR"  address="0xa"  permission="r"
                description="The gain error for the ADC offset calibration is stored at this location (see
                             System Monitor Calibration, page 31).">
            <node id="MAGNITUDE"  address="0x0"  mask="0x1f" permission="r"
                  description="These five bits store the magnitude information for the gain correction factor."/>
            <node id="SIGN"  address="0x0"  mask="0x20" permission="r"
                  description="If this bit is a logic 1, then the correction factor is positive, corresponding to MAGNITUDE.
                               If it is 0, then the correction factor is negative, corresponding to -(!(MAGNITUDE)+1)"/>
          </node>
          <node id="VAUX"  address="0x10"
                description="Returns the value from the ADC for VAUX[0:15]">
            <node id="VAL_${VAUX_IDX}"  address="0x0"  permission="r"
                  description="Returns the value from the ADC VAUX channel ${VAUX_IDX}
                               The 10 MSBs correspond to the ADC transfer function, 1 LSB corresponds to 0.977 mV"
                  generate="true" generate_size="16" generate_address_step="0x1" generate_idx_var="VAUX_IDX"/>
          </node>
          <node id="FLAG"  address="0x3f"  permission="r"
                description="This register contains general status information - see Figure 8.">
            <node id="OT"  address="0x0"   mask="0x008" permission="r"
                  description="This bit reflects the status of the Over Temperature logic output"/>
            <node id="DIS"  address="0x0"  mask="0x100" permission="r"
                  description="When this bit is a logic 1, the System Monitor is disabled by connecting the supplies and
                               reference inputs to AGND"/>
            <node id="REF"  address="0x0"  mask="0x200" permission="r"
                  description="When this bit is a logic 1, the System Monitor ADC is using the internal voltage reference.
                               When it is a logic 0, then the external reference is being used"/>
          </node>
          <node id="CONTROL"     address="0x40"
                description="These are System Monitor control registers (see page 17).">
            <node id="CONF_REG"  address="0x0"  permission="rw"
                  description="Controls the ADC configuration registers (see Figure 9 and Tables 6 to 11).">
              <node id="CH0"  address="0x0"  mask="0x01" permission="rw"/>
              <node id="CH1"  address="0x0"  mask="0x02" permission="rw"/>
              <node id="CH2"  address="0x0"  mask="0x04" permission="rw"/>
              <node id="CH3"  address="0x0"  mask="0x08" permission="rw"/>
              <node id="CH4"  address="0x0"  mask="0x10" permission="rw"/>

              <node id="ACQ"                  address="0x0"  mask="0x100" permission="rw"/>
              <node id="CONTINUOUS_OR_EVENT"  address="0x0"  mask="0x200" permission="rw"/>
              <node id="BIPOLAR_OR_UNIPOLAR"  address="0x0"  mask="0x400" permission="rw"/>

              <node id="AVG0"  address="0x0"  mask="0x1000" permission="rw"/>
              <node id="AVG1"  address="0x0"  mask="0x2000" permission="rw"/>
              <node id="CAVG"  address="0x0"  mask="0x8000" permission="rw"/>

              <node id="OT  " address="0x1" mask="0x01" permission="rw"/>
              <node id="ALM0" address="0x1" mask="0x02" permission="rw"/>
              <node id="ALM1" address="0x1" mask="0x04" permission="rw"/>
              <node id="ALM2" address="0x1" mask="0x08" permission="rw"/>
              <node id="CAL0" address="0x1" mask="0x10" permission="rw"/>
              <node id="CAL1" address="0x1" mask="0x20" permission="rw"/>
              <node id="CAL2" address="0x1" mask="0x40" permission="rw"/>
              <node id="CAL3" address="0x1" mask="0x80" permission="rw"/>
              <node id="SEQ0" address="0x1" mask="0x1000" permission="rw"/>
              <node id="SEQ1" address="0x1" mask="0x2000" permission="rw"/>

              <node id="CD7" address="0x2" mask="0x8000" permission="rw"/>
              <node id="CD6" address="0x2" mask="0x4000" permission="rw"/>
              <node id="CD5" address="0x2" mask="0x2000" permission="rw"/>
              <node id="CD4" address="0x2" mask="0x1000" permission="rw"/>
              <node id="CD3" address="0x2" mask="0x0800" permission="rw"/>
              <node id="CD2" address="0x2" mask="0x0400" permission="rw"/>
              <node id="CD1" address="0x2" mask="0x0200" permission="rw"/>
              <node id="CD0" address="0x2" mask="0x0100" permission="rw"/>
            </node>

            <node id="SEQUENCER"   address="0x8"
                  description="These registers are used to program the Channel Sequencer functionality
                               (see Channel Sequencer, page 25)">
              <node id="SEQ_${SEQ_IDX}"  address="0x0"  permission="rw"
                    description="Controls the ADC sequencer register ${SEQ_IDX}"
                    generate="true" generate_size="7" generate_address_step="0x1" generate_idx_var="SEQ_IDX"/>
            </node>
            <node id="ALARM_THRESHOLDS"   address="0x10"
                  description="These registers are used to program the alarm thresholds for the automatic alarms on the
                               internally monitored channels, temperature, VCCINT , and VCCAUX (see Automatic Alarms,
                               page 29)">
              <node id="TEMP"    address="0x0"  permission="rw">
                <node id="UPPER" address="0x0"  permission="rw"/>
                <node id="LOWER" address="0x4"  permission="rw"/>
              </node>
              <node id="VCCINT"  address="0x1"  permission="rw">
                <node id="UPPER" address="0x0"  permission="rw"/>
                <node id="LOWER" address="0x4"  permission="rw"/>
              </node>
              <node id="VCCAUX"  address="0x2"  permission="rw">
                <node id="UPPER" address="0x0"  permission="rw"/>
                <node id="LOWER" address="0x4"  permission="rw"/>
              </node>
              <node id="OT"      address="0x3"  permission="rw">
                <node id="UPPER" address="0x0"  permission="rw"/>
                <node id="LOWER" address="0x4"  permission="rw"/>
              </node>
            </node>
          </node>
        </node>

        <node id="ScanController"  address="0x2000"
              description="Module to perform threshold and latency scans in the firmware">
          <node id="THLAT"  address="0x0000000"  permission="rw"
                description="Control the onboard threshold/latency scan routine (per VFAT)">
            <node id="START"  address="0x0"  permission="w"
                  description="Start the specified scan routine
                               Will also empty the results FIFO from the previous scan"/>
            <node id="MODE"  address="0x1"  mask="0xf"  permission="rw"
                  description="Select the scan mode (4 bits):
                               0: Threshold scan using trigger data
                               1: Threshold scan by channel
                               2: Lateny scan
                               3: S-curve scan (per channel)
                               4: Threshold scan using tracking data"/>
            <node id="CHIP"  address="0x2"  mask="0x1f"  permission="rw"
                  description="Select which VFAT2 to scan (5 bits [0,23])"/>
            <node id="CHAN"  address="0x3"  mask="0xff"  permission="rw"
                  description="Select which channel to do a per channel threshold scan on (8 bits [0,255])
                               (only for per-channel threshold scan)"/>
            <node id="MIN"  address="0x4"  mask="0xff"  permission="rw"
                  description="Minimum value of the register to scan from (8 bits [0,255])
                               Default: 0x0"/>
            <node id="MAX"  address="0x5"  mask="0xff"  permission="rw"
                  description="Maximum value of the register to scan to (8 bits [0,255])
                               Default: 0xFF"/>
            <node id="STEP"  address="0x6"  mask="0xff"  permission="rw"
                  description="How much to step the register value by each point (8 bits [0,255])
                               Default: 0x1"/>
            <node id="NTRIGS"  address="0x7"  mask="0x00ffffff"  permission="rw"
                  description="Number of triggers to collect at each scan point
                               Default: 0 = 0xffffff"/>
            <node id="RESULTS"  address="0x8"  mode="non-incremental"  permission="r"
                  description="FIFO holding the scan results
                               This register will return the data
                               points collected by the scan using the following data format:
                               8 MSBits hold the threshold/latency value of the point
                               24 LSBits hold the number of events that have fired
                               If no data is present, an error is returned."/>
            <node id="MONITOR"    address="0x9">
              <node id="STATUS"  address="0x0"  mask="0x000000f"  permission="r"
                    description="[3:0]: Status of the scan module
                                 0 = nothing running
                                 1 = threshold scan running
                                 2 = threshold scan by channel running
                                 3 = latency scan running
                                 4 = s-curve scan running
                                 5 = threshold scan using tracking data" />
              <node id="ERROR"  address="0x0"  mask="0x00000010"  permission="r"
                    description="4: Error bit (scan did not start due to error)"/>
              <node id="READY"  address="0x0"  mask="0x00000020"  permission="r"
                    description="5: Ready bit (data is ready for readout)"/>
              <node id="MASK"   address="0x0"  mask="0xffffff00"  permission="r"
                    description="[31:8]: Mask (mask with the data that is valid)"/>
            </node>
            <node id="RESET"    address="0xa"   permission="w"
                  description="Local reset of the module"/>
          </node>

          <node id="ULTRA"  address="0xB000"  permission="rw"
                description="Control the onboard ultra threshold/latency scan routine">
            <node id="START"  address="0x0"  permission="w"
                  description="Start the specified scan routine
                               Will also empty the results FIFO from the previous scan"/>
            <node id="MODE"  address="0x1"  mask="0xf"  permission="rw"
                  description="Select the scan mode (4 bits):
                               0: Threshold scan using trigger data
                               1: Threshold scan by channel
                               2: Lateny scan
                               3: S-curve scan (per channel)
                               4: Threshold scan using tracking data"/>
            <node id="MASK"  address="0x2"  mask="0x00ffffff"  permission="rw"
                  description="Select which VFATs to scan, 1 masks the VFAT from participating"/>
            <node id="CHAN"  address="0x3"  mask="0xff"  permission="rw"
                  description="Select which channel to do a per channel threshold scan on (8 bits [0,255])
                               (only for per-channel threshold scan)"/>
            <node id="MIN"  address="0x4"  mask="0xff"  permission="rw"
                  description="Minimum value of the register to scan from (8 bits [0,255])
                               Default: 0x0"/>
            <node id="MAX"  address="0x5"  mask="0xff"  permission="rw"
                  description="Maximum value of the register to scan to (8 bits [0,255])
                               Default: 0xFF"/>
            <node id="STEP"  address="0x6"  mask="0xff"  permission="rw"
                  description="How much to step the register value by each point (8 bits [0,255])
                               Default: 0x1"/>
            <node id="NTRIGS"  address="0x7"  mask="0x00ffffff"  permission="rw"
                  description="Number of triggers to collect at each scan point
                               Default: 0 = 0xffffff"/>
            <node id="RESULTS"  address="0x8"
                  description="FIFOs holding the scan results
                               Each register will return the data
                               points collected by the scan using the following data format:
                               8 MSBits hold the threshold/latency value of the point
                               24 LSBits hold the number of events that have fired
                               If no data is present, an error is returned.">
              <node id="VFAT${VFAT_IDX}"  address="0x0"    mode="non-incremental"  permission="r"
                    description="Scan results for VFAT 0"
                    generate="true" generate_size="24" generate_address_step="0x1" generate_idx_var="VFAT_IDX"/>
            </node>
            <node id="MONITOR"    address="0x20">
              <node id="STATUS"  address="0x0"  mask="0x000000f"  permission="r"
                    description="[3:0]: Status of the scan module
                                 0 = nothing running
                                 1 = threshold scan running
                                 2 = threshold scan by channel running
                                 3 = latency scan running
                                 4 = s-curve scan running
                                 5 = threshold scan using tracking data" />
              <node id="ERROR"  address="0x0"  mask="0x00000010"  permission="r"
                    description="4: Error bit (scan did not start due to error)"/>
              <node id="READY"  address="0x0"  mask="0x00000020"  permission="r"
                    description="5: Ready bit (data is ready for readout)"/>
              <node id="MASK"   address="0x0"  mask="0xffffff00"   permission="r"
                    description="[31:8]: Mask (mask with the data that is valid)"/>
            </node>
            <node id="RESET"    address="0x21"   permission="w"
                  description="Local reset of the module"/>
          </node>

          <node id="DAC"    address="0x2000"  permission="rw"
                description="Control the onboard DAC scan routine">
            <node id="START"    address="0x0"  permission="w"
                  description="Start the specified scan routine
                               Will also empty the results FIFO from the previous scan"/>
            <node id="MODE"     address="0x1"  mask="0xf"  permission="rw"
                  description="Select the DAC to scan (4 bits):
                               0: IPreampIn
                               1: IPreampFeed
                               2: IPreampOut
                               3: IShaper
                               4: IShaperFeed
                               5: IComp
                               6: VThreshold1
                               7: VThreshold1
                               8: VCal
                               9: CalOut"/>
            <node id="CHIP"     address="0x2"  mask="0x1f"  permission="rw"
                  description="Select which VFAT2 to scan (5 bits [0,23])"/>
            <node id="MIN"      address="0x3"  mask="0xff"  permission="rw"
                  description="Minimum value of the register to scan from (8 bits [0,255])
                               Default: 0x0"/>
            <node id="MAX"      address="0x4"  mask="0xff"  permission="rw"
                  description="Maximum value of the register to scan to (8 bits [0,255])
                               Default: 0xFF"/>
            <node id="STEP"     address="0x5"  mask="0xff"  permission="rw"
                  description="How much to step the register value by each point (8 bits [0,255])
                               Default: 0x1"/>
            <node id="NTRIGS"   address="0x6"  mask="0xffffff"  permission="rw"
                  description="Number of triggers to collect at each scan point
                               Default: 0 = 0xffffff"/>
            <node id="RESULTS"  address="0x7"  mode="non-incremental"  permission="r"
                  description="FIFO holding the scan results
                               This register will return the data
                               points collected by the scan using the following data format:
                               8 MSBits hold the DAC value of the point
                               24 LSBits hold the mean of the ADC values
                               If no data is present, an error is returned."/>
            <node id="MONITOR"  address="0x8"  mask="0x1"  permission="rw"
                  description="Status monitor for the DAC scan controller (1 bit):
                               0: nothing running
                               1: scanning a DAC"/>
            <node id="RESET"    address="0x9"   permission="w"
                  description="Local reset of the module"/>
          </node>
        </node>

        <node id="GEB"  address="0x0000"
              description="complete GEB address table, including:
                           the individual VFAT I2C request module
                           the broadcast VFAT I2C request module">
          <node id="Broadcast"  address="0x1000"
                description="Module to broadcast transactions to multiple VFATs">
            <node id="Request"  address="0x000"
                  description="Which register request will be broadcast to all (non-masked) VFATs">
              <node id="ContReg0"     address="0x00"   permission="rw"
                    description="VFAT control register 0
                                 Hardwired sleep value 0x00
                                 Software default value 0x00"/>
              <node id="ContReg1"     address="0x01"   permission="rw"
                    description="VFAT control register 1"/>
              <node id="IPreampIn"    address="0x02"   permission="rw"
                    description="Hardwired sleep value 0x00
                                 Software default value 0xa8"/>
              <node id="IPreampFeed"  address="0x03"   permission="rw"
                    description="Hardwired sleep value 0x00
                                 Software default value 0x50"/>
              <node id="IPreampOut"   address="0x04"   permission="rw"
                    description="Hardwired sleep value 0x00
                                 Software default value 0x96"/>
              <node id="IShaper"      address="0x05"   permission="rw"
                    description="Hardwired sleep value 0x00
                                 Software default value 0x96"/>
              <node id="IShaperFeed"  address="0x06"   permission="rw"
                    description="Hardwired sleep value 0x00
                                 Software default value 0x64"/>
              <node id="IComp"        address="0x07"   permission="rw"
                    description="Hardwired sleep value 0x00
                                 Software default value 0x78"/>
              <node id="ChipID0"      address="0x08"   permission="r"
                    description="8 least significant bits in the chip ID"/>
              <node id="ChipID1"      address="0x09"   permission="r"
                    description="8 most significant bits in the chip ID"/>
              <node id="UpsetReg"     address="0x0a"   permission="r"
                    description=""/>
              <node id="HitCount0"    address="0x0b"   permission="r"
                    description=""/>
              <node id="HitCount1"    address="0x0c"   permission="r"
                    description=""/>
              <node id="HitCount2"    address="0x0d"   permission="r"
                    description=""/>
              <node id="ExtRegPointer"  address="0x0e"   permission="rw"
                    description="Pointer to one of the extended registers
                                 Hardwired sleep value 0x00
                                 Software default value 0x00"/>
              <node id="ExtRegData"     address="0x0f"   permission="rw"
                    description="Data to be written to the extended register
                                 pointed to by ExtRegPointer
                                 Hardwired sleep value 0x00
                                 Software default value 0x00"/>

              <!--Extended registers, addressed by ExtRegPointer and ExtRegData
                           (should be taken care of in the AMC-Optohybrid firmware-->
              <node id="Latency"       address="0x10"   permission="rw"
                    description="Programs the L1A latency, each bit is a single clock
                                 cycle (0-255 clock cycles, up to 6.4us)
                                 Hardwired sleep value 0x80
                                 Software default value 0x80"/>
              <node id="VFATChannels"  address="0x11"
                    description="Registers for the individual VFAT channels
                                 Hardwired sleep value 0x00
                                 Software default value 0x00">
                <node id="ChanReg${CHANNEL_IDX}"  address="0x00"  permission="rw"
                      description="Register for VFAT channel ${CHANNEL_IDX}"
                      generate="true" generate_size="128" generate_address_step="0x1" generate_idx_var="CHANNEL_IDX">
                  <!-- Due to RMW behaviour, don't allow masked registers in broadcast module-->
                  <!--   <node id="PULSE"  address="0x00"  mask="0x40"  permission="rw" -->
	          <!--         description="Enable a calibration pulse to the channel"/> -->
                  <!--   <node id="MASK"   address="0x00"  mask="0x20"  permission="rw" -->
	          <!--         description="Mask the chanel"/> -->
                  <!--   <node id="TRIM"   address="0x00"  mask="0x1f"  permission="rw" -->
	          <!--         description="Set the channel trimDAC"/> -->
                </node>
              </node> <!-- end of VFATChannels -->

              <node id="VCal"           address="0x91"   permission="rw"
                    description="Determines the variable calibration voltage
                                 (between 0.877V and 1.074V)
                                 Hardwired sleep value 0x00
                                 Software default value 0x64"/>
              <node id="VThreshold1"    address="0x92"   permission="rw"
                    description="Hardwired sleep value 0x00
                                 Software default value 0x00"/>
              <node id="VThreshold2"    address="0x93"   permission="rw"
                    description="Hardwired sleep value 0x00
                                 Software default value 0x1a"/>
              <node id="CalPhase"       address="0x94"   permission="rw"
                    description="Hardwired sleep value 0x00
                                 Software default value 0x00"/>
              <node id="ContReg2"       address="0x95"   permission="rw"
                    description="Third control register
                                 Hardwired sleep value 0x00
                                 Software default value 0x00"/>
              <node id="ContReg3"       address="0x96"   permission="rw"
                    description="Fourth control register
                                 Hardwired sleep value 0x00
                                 Software default value 0x00"/>
              <node id="Spare"          address="0x97"   permission="rw"
                    description="Spare register, not currently implemented"/>
            </node> <!-- end of Request -->
            <node id="Mask"  address="0x100"  permission="rw"
                  description="24 bit mask for which VFATs will/not receive the I2C register request broadcast
                               0 means associated VFAT will receive the request,
                               1 means associated VFAT will not receive the request"/>
            <node id="Results"  address="0x101"  mode="non-incremental"  permission="r"
                  description="FIFO holding the responses from each un-masked VFAT
                               This register will return the
                               response of each individual request made to the VFAT2s:
                               8 MSBits are constant 0s
                               8 next bits hold the status of the transaction
                               8 next bits are the VFAT2 id (0 to 23)
                               8 LSBits hold response from the VFAT2
                               If no data is present, an error is returned."/>
            <node id="Reset"    address="0x102"  permission="w"
                  description="Reset the module"/>
            <node id="Running"  address="0x103"  mask="0x1"  permission="r"
                  description="0: no broadcast transaction in progress
                               1: broadcast transaction is in progress"/>
          </node> <!-- end of Broadcast -->

          <node id="VFATS"  address="0x100000"
                description="VFAT registers controled by the AMC user registers">

            <node id="VFAT${VFAT_IDX}"   address="0x0"
              description="VFAT #{VFAT_IDX} registers"
                  generate="true" generate_size="24" generate_address_step="0x100" generate_idx_var="VFAT_IDX">
              <node id="ContReg0"     address="0x00"   permission="rw"
                    description="VFAT control register 0
                                 Hardwired sleep value 0x00
                                 Software default value 0x00"/>
              <node id="ContReg1"     address="0x01"   permission="rw"
                    description="VFAT control register 1"/>
              <node id="IPreampIn"    address="0x02"   permission="rw"
                    description="Hardwired sleep value 0x00
                                 Software default value 0xa8"/>
              <node id="IPreampFeed"  address="0x03"   permission="rw"
                    description="Hardwired sleep value 0x00
                                 Software default value 0x50"/>
              <node id="IPreampOut"   address="0x04"   permission="rw"
                    description="Hardwired sleep value 0x00
                                 Software default value 0x96"/>
              <node id="IShaper"      address="0x05"   permission="rw"
                    description="Hardwired sleep value 0x00
                                 Software default value 0x96"/>
              <node id="IShaperFeed"  address="0x06"   permission="rw"
                    description="Hardwired sleep value 0x00
                                 Software default value 0x64"/>
              <node id="IComp"        address="0x07"   permission="rw"
                    description="Hardwired sleep value 0x00
                                 Software default value 0x78"/>
              <node id="ChipID0"      address="0x08"   permission="r"
                    description="8 least significant bits in the chip ID"/>
              <node id="ChipID1"      address="0x09"   permission="r"
                    description="8 most significant bits in the chip ID"/>
              <node id="UpsetReg"     address="0x0a"   permission="r"
                    description=""/>
              <node id="HitCount0"    address="0x0b"   permission="r"
                    description=""/>
              <node id="HitCount1"    address="0x0c"   permission="r"
                    description=""/>
              <node id="HitCount2"    address="0x0d"   permission="r"
                    description=""/>
              <node id="ExtRegPointer"  address="0x0e"   permission="rw"
                    description="Pointer to one of the extended registers
                                 Hardwired sleep value 0x00
                                 Software default value 0x00"/>
              <node id="ExtRegData"     address="0x0f"   permission="rw"
                    description="Data to be written to the extended register
                                 pointed to by ExtRegPointer
                                 Hardwired sleep value 0x00
                                 Software default value 0x00"/>

              <!--Extended registers, addressed by ExtRegPointer and ExtRegData
                           (should be taken care of in the AMC-Optohybrid firmware-->
              <node id="Latency"       address="0x10"   permission="rw"
                    description="Programs the L1A latency, each bit is a single clock
                                 cycle (0-255 clock cycles, up to 6.4us)
                                 Hardwired sleep value 0x80
                                 Software default value 0x80"/>
              <node id="VFATChannels"  address="0x11"
                    description="Registers for the individual VFAT channels
                                 Hardwired sleep value 0x00
                                 Software default value 0x00">
                <node id="ChanReg${CHANNEL_IDX}"  address="0x00"  permission="rw"
                      description="Register for VFAT channel ${CHANNEL_IDX}"
                      generate="true" generate_size="128" generate_address_step="0x1" generate_idx_var="CHANNEL_IDX">
                  <node id="PULSE"  address="0x00"  mask="0x40"  permission="rw"
	                description="Enable a calibration pulse to the channel"/>
                  <node id="MASK"   address="0x00"  mask="0x20"  permission="rw"
	                description="Mask the chanel"/>
                  <node id="TRIM"   address="0x00"  mask="0x1f"  permission="rw"
	                description="Set the channel trimDAC"/>
                </node>
              </node> <!-- end of VFATChannels -->

              <node id="VCal"           address="0x91"   permission="rw"
                    description="Determines the variable calibration voltage
                                 (between 0.877V and 1.074V)
                                 Hardwired sleep value 0x00
                                 Software default value 0x64"/>
              <node id="VThreshold1"    address="0x92"   permission="rw"
                    description="Hardwired sleep value 0x00
                                 Software default value 0x00"/>
              <node id="VThreshold2"    address="0x93"   permission="rw"
                    description="Hardwired sleep value 0x00
                                 Software default value 0x1a"/>
              <node id="CalPhase"       address="0x94"   permission="rw"
                    description="Hardwired sleep value 0x00
                                 Software default value 0x00"/>
              <node id="ContReg2"       address="0x95"   permission="rw"
                    description="Third control register
                                 Hardwired sleep value 0x00
                                 Software default value 0x00"/>
              <node id="ContReg3"       address="0x96"   permission="rw"
                    description="Fourth control register
                                 Hardwired sleep value 0x00
                                 Software default value 0x00"/>
              <node id="Spare"          address="0x97"   permission="rw"
                    description="Spare register, not currently implemented"/>
            </node> <!-- end of VFAT -->
          </node> <!-- end VFATs -->
        </node> <!-- end of GEB -->
      </node> <!-- end OH${OH_IDX} block -->
    </node> <!-- end OptoHybrid block -->

    <node id="GLIB_SYSTEM" address="0x910000"
          description="Legacy system registers (taken from GLIB system core).
                       These should be removed once the software is made compatible with the new system registers."
          fw_is_module="true"
          fw_is_module_external="true">

      <node id="SYSTEM"  address="0x00000000"  permission="r"
            description="GLIB system registers">
        <node id="BOARD_ID" address="0x0"
              description="GLIB board ID code">
          <node id="CHAR1"  mask="0xff000000"  permission="r" address="0x00000000"/>
          <node id="CHAR2"  mask="0x00ff0000"  permission="r" address="0x00000000"/>
          <node id="CHAR3"  mask="0x0000ff00"  permission="r" address="0x00000000"/>
          <node id="CHAR4"  mask="0x000000ff"  permission="r" address="0x00000000"/>
        </node> <!--end board_id -->

        <node id="SYSTEM_ID"  address="0x1" permission="r"
              description="GLIB system ID code">
          <node id="CHAR1"  mask="0xff000000"  permission="r" address="0x00000000"/>
          <node id="CHAR2"  mask="0x00ff0000"  permission="r" address="0x00000000"/>
          <node id="CHAR3"  mask="0x0000ff00"  permission="r" address="0x00000000"/>
          <node id="CHAR4"  mask="0x000000ff"  permission="r" address="0x00000000"/>
        </node> <!--end system_id -->

        <node id="FIRMWARE"  address="0x2"  permission="r"
              description="GLIB firmware date (dd.mm.yy) and version number (x.y.z)">
          <node id="ID"     mask="0xffff0000"    permission="r" address="0x00000000"/>
          <node id="MAJOR"  mask="0xf0000000"    permission="r" address="0x00000000"/>
          <node id="MINOR"  mask="0x0f000000"    permission="r" address="0x00000000"/>
          <node id="BUILD"  mask="0x00ff0000"    permission="r" address="0x00000000"/>
          <node id="DATE"   mask="0x0000ffff"    permission="r" address="0x00000000"/>
          <node id="YY"     mask="0x0000fe00"    permission="r" address="0x00000000"/>
          <node id="MM"     mask="0x000001e0"    permission="r" address="0x00000000"/>
          <node id="DD"     mask="0x0000001f"    permission="r" address="0x00000000"/>
        </node> <!--end firmware_id -->

        <node id="TEST"  address="0x0"     permission="r"
              description="Register for testing purposes only"/>

        <node id="CLK_CTRL"  address="0x0"
              description="Controls the external clocking circuitry">
          <node id="PCIE_CLK_FSEL"	  mask="0x00000001" address="0x0" permission="r"
                description="output multiplication factor:0->2.5x, 1->1.25x"/>
          <node id="PCIE_CLK_MR"	  mask="0x00000002" address="0x0" permission="r"
                description="master reset: 1 -> reset, 0 -> normal"/>
          <node id="PCIE_CLK_OE"	  mask="0x00000004" address="0x0" permission="r"
                description="output enable"/>
          <node id="CDCE_POWERUP"	  mask="0x00000010" address="0x0" permission="r"
                description="control power up of CDCE"/>
          <node id="CDCE_REFSEL"	  mask="0x00000020" address="0x0" permission="r"
                description="clock input selection: 1 -> CLK1, 0 -> CLK2"/>
          <node id="CDCE_SYNC"	          mask="0x00000040" address="0x0" permission="r"
                description="CDCE synchronization, transition from 0 to 1 needed to resync"/>
          <node id="CDCE_CTRLSEL"         mask="0x00000080" address="0x0" permission="r"
                description="who drives CDCE: 0 -> system, 1 -> user"/>
          <node id="TCLKB_DR_EN"	  mask="0x00000200" address="0x0" permission="r"
                description="TCKLB to backplane enable"/>
          <node id="XPOINT2" address="0x0" permission="r"
                description="configure the routing of the clocks on the xpoint2 switch
                             if bit 0 is 0 and bit 1 is 0, the output takes input 1 as the source
                             if bit 0 is 0 and bit 1 is 1, the output takes input 2 as the source
                             if bit 0 is 1 and bit 1 is 0, the output takes input 3 as the source
                             if bit 0 is 1 and bit 1 is 1, the output takes input 4 as the source
                             ">
            <node id="S10"	  mask="0x00001000" address="0x0" permission="r"
                  description="output 1 first bit"/>
            <node id="S11"	  mask="0x00002000" address="0x0" permission="r"
                  description="output 1 second bit"/>
          </node> <!-- end xpoint2 configuration-->
          <node id="XPOINT1" address="0x0" permission="r"
                description="configure the routing of the clocks on the xpoint1 switch
                             if bit 0 is 0 and bit 1 is 0, the output takes input 1 as the source
                             if bit 0 is 0 and bit 1 is 1, the output takes input 2 as the source
                             if bit 0 is 1 and bit 1 is 0, the output takes input 3 as the source
                             if bit 0 is 1 and bit 1 is 1, the output takes input 4 as the source
                             ">
            <node id="S10"	  mask="0x00010000" address="0x0" permission="r"
                  description="output 1 first bit"/>
            <node id="S11"	  mask="0x00020000" address="0x0" permission="r"
                  description="output 1 second bit"/>
            <node id="S20"	  mask="0x00040000" address="0x0" permission="r"
                  description="output 2 first bit"/>
            <node id="S21"	  mask="0x00080000" address="0x0" permission="r"
                  description="output 2 second bit"/>
            <node id="S30"	  mask="0x00100000" address="0x0" permission="r"
                  description="output 3 first bit"/>
            <node id="S31"	  mask="0x00200000" address="0x0" permission="r"
                  description="output 3 second bit"/>
            <node id="S40"	  mask="0x00400000" address="0x0" permission="r"
                  description="output 4 first bit"/>
            <node id="S41"	  mask="0x00800000" address="0x0" permission="r"
                  description="output 4 second bit"/>
          </node> <!-- end xpoint1 configuration-->

          <node id="GBT_PHASE_MON_RESET"  mask="0x04000000" address="0x0" permission="r"
                description=""/>
          <node id="FPGA_PROGRAM_B_TRST"  mask="0x10000000" address="0x0" permission="r"
                description=""/>
        </node> <!--end ctrl-->

        <node id="FLASH_CTRL"  address="0x0"  permission="r"
              description="Flash control register">
          <node id="ICAP_PAGE"   mask="0x00000003" address="0x0"  permission="r"/>
          <node id="ICAP_TRIGG"  mask="0x00000010" address="0x0"  permission="r"/>
        </node> <!--end ctrl_2-->

        <node id="STATUS"  address="0x0"
              description="Status from various external components">
          <node id="SFP1"
                description="status bits for SFP cage 1">
            <node id="STATUS"      mask="0x00000007" address="0x0"  permission="r"
                  description="SFP1 status, bit 1 Mod_abs, bit 2 RxLOS, bit 3 TxFault"/>
            <node id="Mod_abs"     mask="0x00000001" address="0x0"  permission="r"/>
            <node id="RxLOS" 	   mask="0x00000002" address="0x0"  permission="r"/>
            <node id="TxFault"     mask="0x00000004" address="0x0"  permission="r"/>
          </node>

          <node id="SFP2"
                description="status bits for SFP cage 2">
            <node id="STATUS"      mask="0x00000070" address="0x0"  permission="r"
                  description="SFP2 status, bit 1 Mod_abs, bit 2 RxLOS, bit 3 TxFault"/>
            <node id="Mod_abs"     mask="0x00000010" address="0x0"  permission="r"/>
            <node id="RxLOS" 	   mask="0x00000020" address="0x0"  permission="r"/>
            <node id="TxFault"     mask="0x00000040" address="0x0"  permission="r"/>
          </node>

          <node id="SFP3"
                description="status bits for SFP cage 3">
            <node id="STATUS"      mask="0x00000700" address="0x0"  permission="r"
                  description="SFP3 status, bit 1 Mod_abs, bit 2 RxLOS, bit 3 TxFault"/>
            <node id="Mod_abs"     mask="0x00000100" address="0x0"  permission="r"/>
            <node id="RxLOS" 	   mask="0x00000200" address="0x0"  permission="r"/>
            <node id="TxFault"     mask="0x00000400" address="0x0"  permission="r"/>
          </node>

          <node id="SFP4"
                description="status bits for SFP cage 4">
            <node id="STATUS"      mask="0x00007000" address="0x0"  permission="r"
                  description="SFP4 status, bit 1 Mod_abs, bit 2 RxLOS, bit 3 TxFault"/>
            <node id="Mod_abs"     mask="0x00001000" address="0x0"  permission="r"/>
            <node id="RxLOS" 	   mask="0x00002000" address="0x0"  permission="r"/>
            <node id="TxFault"     mask="0x00004000" address="0x0"  permission="r"/>
          </node>

          <node id="GBE_INT" 		   mask="0x00010000" address="0x0"  permission="r"
                description="GBE Phy interrupt"/>
          <node id="FMC1_PRESENT"    	   mask="0x00020000" address="0x0"  permission="r"
                description="FMC present in FMC slot 1"/>
          <node id="FMC2_PRESENT"    	   mask="0x00040000" address="0x0"  permission="r"
                description="FMC present in FMC slot 2"/>
          <node id="FPGA_RESET"	           mask="0x00080000" address="0x0"  permission="r"
                description="state of the FPGA reset line, driven by the CPLD"/>
          <node id="V6_CPLD"         	   mask="0x03f00000" address="0x0"  permission="r"
                description="state of the 6-bit bus between the FPGA and the CPLD"/>
          <node id="CDCE_LOCK"             mask="0x08000000" address="0x0"  permission="r"
                description="State of the CDCE"/>

          <node id="SFP_PHASE_MON"
                description="">
            <node id="DONE"    mask="0x10000000" address="0x0"  permission="r"
                  description=""/>
            <node id="OK"      mask="0x20000000" address="0x0"  permission="r"
                  description=""/>
          </node>

          <node id="FMC1_PHASE_MON"
                description="">
            <node id="DONE"   mask="0x40000000" address="0x0"  permission="r"
                  description=""/>
            <node id="OK"     mask="0x80000000" address="0x0"  permission="r"
                  description=""/>
          </node>
        </node>

        <node id="STATUS_2"   address="0x0"   permission="r"
              description="Currently unused"/>

        <node id="SRAM" address="0x0"
              description="SRAM interface control and status registers, and banks 1 and 2">
          <node id="CTRL" address="0x0"  permission="r"
                description="SRAM interface control register">
            <node id="SRAM1_USER_LOGIC"	mask="0x00000001" address="0x0"  permission="r"/>
            <node id="SRAM1_BIST_RUN"	mask="0x00000002" address="0x0"  permission="r"/>
            <node id="SRAM2_USER_LOGIC"	mask="0x00010000" address="0x0"  permission="r"/>
            <node id="SRAM2_BIST_RUN"	mask="0x00020000" address="0x0"  permission="r"/>
            <node id="FLASH_SELECT"	mask="0x00100000" address="0x0"  permission="r"/>
          </node> <!--end ctrl_sram-->

          <node id="STATUS"  address="0x0"  permission="r"
                description="SRAM interface status register">
            <node id="SRAM1_BIST_DONE"	  mask="0x00000001" address="0x0"  permission="r"/>
            <node id="SRAM1_BIST_OK"	  mask="0x00000002" address="0x0"  permission="r"/>
            <node id="SRAM1_BIST_ERRORS"  mask="0x00000ff0" address="0x0"  permission="r"/>
            <node id="SRAM2_BIST_DONE"	  mask="0x00010000" address="0x0"  permission="r"/>
            <node id="SRAM2_BIST_OK"	  mask="0x00020000" address="0x0"  permission="r"/>
            <node id="SRAM2_BIST_ERRORS"  mask="0x0ff00000" address="0x0"  permission="r"/>
          </node> <!--end status_sram-->
        </node>

        <node id="SPI"  address="0x0"
              description="SPI interface: data from FPGA to clock synthesizer">
          <node id="TxDATA"  address="0x0"   permission="r"
                description="SPI interface: data from FPGA to clock synthesizer"/>

          <node id="COM"  address="0x0"  permission="r"
                description="SPI interface: configuration (polarity, phase, frequency, etc.,">
            <node id="Autoclear"  mask="0xf0000000" address="0x0"  permission="r"
                  description=""/>
            <node id="Reserved"   mask="0x0ffff000"  address="0x0"  permission="r"
                  description="reserved, always keep to 0xFA38"/>
            <node id="Prescale"   mask="0x00000fff" address="0x0"  permission="r"
                  description="SPI clk (MHz)=62.5/prescaler, suggested default 0x014"/>
            <node id="Strobe"     mask="0x80000000" address="0x0"  permission="r"
                  description="execute transaction, clears automatically"/>
          </node> <!--end spi_command register-->

          <node id="RxDATA"  address="0x0"   permission="r"
                description="SPI interface: data from clock synthesizer to FPGA"/>
        </node>

        <node id="I2C"  address="0x0"
              description="I2C interface">
          <node id="SETTINGS"  address="0x0"  permission="r"
                description="I2C interface: configuration (bus select, frequency, etc., only in bench mode)">
            <node id="ENABLE"      mask="0x00000800" address="0x0"  permission="r"
                  description="for FW version 5.3 and higher, enable is bit 15(0x8000) instead of bit 11(0x800)"/>
            <node id="Reserved"    mask="0x00001000" address="0x0"  permission="r"
                  description="for FW version 5.3 and higher, reserved bits are [14:13](0x6000) instead of bit 12(0x1000)"/>
            <node id="BUS_SELECT"  mask="0x00000400" address="0x0"  permission="r"
                  description="for FW version 5.3 and higher, bus select is [12:10](0x1c00) instead of just bit 10(0x400)"/>
            <node id="PRESCALER"   mask="0x000003ff" address="0x0"  permission="r"
                  description="I2C clk(kHz)=62.5/prescale"/>
          </node> <!--end i2c_settings-->

          <node id="COM"  address="0x0"  permission="r"
                description="I2C interface: transaction parameters (slave address, drive to slave, etc., only in bench mode)">
            <node id="Autoclear"   mask="0xf0000000" address="0x0"  permission="r"
                  description="special feature of this register, clears automatically the upper 4 bits"/>
            <node id="Strobe"      mask="0x80000000" address="0x0"  permission="r"
                  description="Execute I2C strobe signal, autoclears"/>
            <node id="MODE16"      mask="0x02000000" address="0x0"  permission="r"
                  description="16-bit operation mode, (PHY only) 0-> standard 8-bit mode, 1->16-bit mode"/>
            <node id="Res2"        mask="0x01000000"  address="0x0"  permission="r"
                  description="reserved, keep to 0"/>
            <node id="WRITE"       mask="0x00800000" address="0x0"  permission="r"
                  description="Write enable"/>
            <node id="SLV_ADDR"    mask="0x007f0000" address="0x0"  permission="r"
                  description="Slave address"/>
            <node id="Res"         mask="0x0000ff00" address="0x0"  permission="r"
                  description="reserved, keep to 0x00"/>
            <node id="WRDATA"      mask="0x000000ff" address="0x0"  permission="r"
                  description="Byte to write to the I2C slave"/>
          </node> <!--end i2c_command-->

          <node id="REPLY"  address="0x0"  permission="r"
                description="I2C interface: transaction reply (status, data from drive, etc., only in bench mode">
            <node id="STATUS"  mask="0x0c000000" address="0x0"  permission="r"
                  description="status bits: 01->success, 11->failed,00/10->pending"/>
            <node id="DATA_LO" mask="0x000000ff" address="0x0"  permission="r"
                  description="low 8 bits of reply"/>
            <node id="DATA_HI" mask="0x0000ff00" address="0x0"  permission="r"
                  description="high 8 bits of reply"/>
            <node id="8b"      mask="0x000000ff" address="0x0"  permission="r"
                  description="8-bit reply"/>
            <node id="16b"     mask="0x0000ffff" address="0x0"  permission="r"
                  description="Full 16 bit reply"/>
          </node> <!--end i2c_reply-->
        </node>

        <node id="SFP_PHASE_MON">
          <node id="CTRL"  address="0x0"  permission="r"
              description="">
            <node id="LOWER"  mask="0x000000ff" address="0x0"  permission="r"/>
            <node id="UPPER"  mask="0x0000ff00" address="0x0"  permission="r"/>
          </node> <!--end sfp_phase_mon_ctrl-->

          <node id="STATS"  address="0x0"   permission="r"
              description=""/>
        </node> <!--end sfp_phase_mon-->

        <node id="FMC1_PHASE_MON">
          <node id="CTRL"  address="0x0"  permission="r"
                description="">
            <node id="LOWER"  mask="0x000000ff" address="0x0"  permission="r"/>
            <node id="UPPER"  mask="0x0000ff00" address="0x0"  permission="r"/>
          </node> <!--end fmc1_phase_mon_ctrl-->

          <node id="STATS"  address="0x0"   permission="r"
              description=""/>
        </node> <!--end fmc1_phase_mon-->

        <node id="MAC"  address="0x0"  permission="r"
              description="firmware version 5.3 and above has different values, as in the description">
          <node id="IP_SOURCE"  address="0x0"  permission="r"  mask="0x0fff0000"
                description=""/>
          <node id="UPPER"      address="0x0"  permission="r"  mask="0x0000ffff"
                description="5.3 and up this is B1"/>
          <node id="B5"         address="0x0"  permission="r"  mask="0x0000ff00"
                description="5.3 and up this is B1"/>
          <node id="B4"         address="0x0"  permission="r"  mask="0x000000ff"
                description="5.3 and up this is B2"/>
          <node id="LOWER"      address="0x0"  permission="r" 
                description="5.3 and up this is B1"/>
          <node id="B3"         address="0x0"  permission="r"  mask="0xff000000"
                description="5.3 and up this is B3"/>
          <node id="B2"         address="0x0"  permission="r"  mask="0x00ff0000"
                description="5.3 and up this is B4"/>
          <node id="B1"         address="0x0"  permission="r"  mask="0x0000ff00"
                description="5.3 and up this is B5"/>
          <node id="B0"         address="0x0"  permission="r"  mask="0x000000ff"
                description="5.3 and up this is B6"/>
        </node> <!--end mac_info-->

        <node id="IP_INFO"  address="0x0"
              description="only in firmware versions less than 5.3">
          <node id="B3"   mask="0xff000000" address="0x0"  permission="r"/>
          <node id="B2"   mask="0x00ff0000" address="0x0"  permission="r"/>
          <node id="B1"   mask="0x0000ff00" address="0x0"  permission="r"/>
          <node id="B0"   mask="0x000000ff" address="0x0"  permission="r"/>
        </node> <!--end ip_info-->

        <node id="HW_ID"  address="0x0"
              description="only in firmware versions 5.3 and up">
          <node id="B1"   address="0x0"  permission="r"  mask="0x0000ff00" />
          <node id="B2"   address="0x0"  permission="r"  mask="0x000000ff" />
          <node id="B3"   address="0x0"  permission="r"  mask="0xff000000" />
          <node id="B4"   address="0x0"  permission="r"  mask="0x00ff0000" />
          <node id="B5"   address="0x0"  permission="r"  mask="0x0000ff00" />
          <node id="B6"   address="0x0"  permission="r"  mask="0x000000ff" />
        </node>
        <!--end ip_info-->
      </node> <!--end GLIB system registers -->

      <node id="SRAM1"  address="0x0"   permission="r"
            description="SRAM1 memory space "/>

      <node id="SRAM2"  address="0x0"   permission="r"
            description="SRAM2 memory space"/>

      <node id="ICAP"  address="0x0"  mode="non-incremental"  permission="r"
            description="ICAP memory space (seems to not work at the moment)"/>

      <node id="FLASH"  address="0x0"  description="FLASH memory banks">
        <node id="BANK_15" description="512Kword">
          <node id="BLOCK_130"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_129"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_128"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_127"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_126"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_125"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_124"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_123"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_15-->

        <node id="BANK_14" description="512Kword">
          <node id="BLOCK_122"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_121"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_120"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_119"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_118"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_117"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_116"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_115"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_14-->

        <node id="BANK_13" description="512Kword">
          <node id="BLOCK_114"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_113"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_112"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_111"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_110"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_109"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_108"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_107"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_13-->

        <node id="BANK_12" description="512Kword">
          <node id="BLOCK_106"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_105"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_104"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_103"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_102"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_101"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_100"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_99"   address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_12-->

        <node id="BANK_11" description="512Kword">
          <node id="BLOCK_98"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_97"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_96"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_95"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_94"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_93"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_92"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_91"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_11-->

        <node id="BANK_10" description="512Kword">
          <node id="BLOCK_90"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_89"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_88"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_87"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_86"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_85"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_84"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_83"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_10-->

        <node id="BANK_9" description="512Kword">
          <node id="BLOCK_82"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_81"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_80"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_79"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_78"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_77"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_76"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_75"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_9-->

        <node id="BANK_8" description="512Kword">
          <node id="BLOCK_74"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_73"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_72"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_71"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_70"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_69"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_68"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_67"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_8-->

        <node id="BANK_7" description="512Kword">
          <node id="BLOCK_66"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_65"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_64"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_63"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_62"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_61"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_60"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_59"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_7-->

        <node id="BANK_6" description="512Kword">
          <node id="BLOCK_58"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_57"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_56"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_55"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_54"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_53"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_52"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_51"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_6-->

        <node id="BANK_5" description="512Kword">
          <node id="BLOCK_50"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_49"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_48"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_47"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_46"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_45"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_44"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_43"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_5-->

        <node id="BANK_4" description="512Kword">
          <node id="BLOCK_42"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_41"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_40"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_39"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_38"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_37"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_36"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_35"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_4-->

        <node id="BANK_3" description="512Kword">
          <node id="BLOCK_34"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_33"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_32"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_31"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_30"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_29"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_28"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_27"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_3-->

        <node id="BANK_2" description="512Kword">
          <node id="BLOCK_26"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_25"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_24"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_23"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_22"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_21"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_20"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_19"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_2-->

        <node id="BANK_1" description="512Kword">
          <node id="BLOCK_18"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_17"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_16"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_15"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_14"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_13"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_12"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_11"  address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end BANK_1-->

        <node id="PARAM_BANK" description="512Kword">
          <node id="BLOCK_10"  address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_9"   address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_8"   address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_7"   address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_6"   address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_5"   address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_4"   address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_3"   address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_2"   address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_1"   address="0x0"   permission="r" description="64Kword"/>
          <node id="BLOCK_0"   address="0x0"   permission="r" description="64Kword"/>
        </node> <!--end PARAM_BANK-->
      </node>

      <node id="BOARD_ID" address="0x0" permission="r"
            description="GLIB Board ID code"
            fw_signal="legacy_board_id"/>
      <node id="SYSTEM_ID" address="0x1" permission="r"
            description="GLIB System ID code"
            fw_signal="legacy_sys_id"/>
      <node id="FIRMWARE_VERSION" address="0x2" permission="r"
            description="GLIB firmware version + firmware date"
            fw_signal="legacy_fw_version"/>
    </node> <!-- end of GLIB_SYSTEM -->

  </node>
</node>
